%%
%% 研究報告用スイッチ
%% [techrep]
%%
%% 欧文表記無しのスイッチ(etitle,jkeyword,eabstract,ekeywordは任意)
%% [noauthor]
%%

\documentclass[submit,techreq,noauthor,onecolumn]{ipsj}


\usepackage[dvipdfmx]{graphicx}
\usepackage{latexsym}

\def\Underline{\setbox0\hbox\bgroup\let\\\endUnderline}
\def\endUnderline{\vphantom{y}\egroup\smash{\underline{\box0}}\\}
\def\|{\verb|}

\setcounter{page}{1}

\pagestyle{empty}
\begin{document}


\title{Applied Type System}

\author{Hongwei Xi}{}{}

\begin{abstract}
Pure Type Systemフレームワーク ({\it PTS}) は型システムをデザイン/形式化する単純で一般的なアプローチを提供します。
けれども依存型の存在を認めると、一般帰納、再帰型、作用 (例: 例外、参照、入出力)、などのような多くの実際のプログラミングの機能に {\it PTS} を適用させることが難しくなります。
この論文では、実際のプログラミングの機能をサポートする型システムをたやすくデザイン/形式化できる、新しい Applied Type System ({\it ATS}) フレームワークを提案します。
{\it ATS} の鍵となる突出した機能は、コンストラクトされて評価されるプログラムを含む動的な部分から、形作られて根拠となる型を含む静的な部分を完全に分離することにあります。
この分離を用いると、{\it PTS} では許可されていましたが、プログラムが型の中に現われることは不可能になります。
{\it ATS} の形式的な開発だけでなく、実用的なプログラミングのための型システムを作るフレームワークとして {\it ATS} を使ったいくつかの例も紹介します。

この翻訳の元論文は http://www.ats-lang.org/PAPER/ATS-types03.pdf です。
\end{abstract}

\maketitle
\thispagestyle{empty}

\section{はじめに}

Pure Type Systemフレームワーク ({\it PTS}) [Bar92] は型システムをデザイン/形式化する単純で一般的なアプローチを提供します。
けれども依存型の存在を認めると、多くの実際のプログラミングの機能に {\it PTS} を適用させることが難しくなります。
とりわけ、一般帰納 [CS87]、再帰型 [Men87]、作用 [HMST95]、例外 [HN88]、入出力が存在するとき {\it PTS} を使って純粋性を担保するためには、多大な努力が必要になることを私達は学びました。
このような {\it PTS} の限界に対処するために、実際のプログラミングの機能をサポートする型システムをたやすくデザイン/形式化できる、新しい Applied Type System ({\it ATS}) フレームワークを提案します。
{\it ATS} の鍵となる突出した機能は、コンストラクトされて評価されるプログラムを含む動的な部分から、形作られて根拠となる型を含む静的な部分を完全に分離することにあります。
この分離は Dependent ML (DML) [XP99,Xi98] で開発された制限された依存型の成果に由来していて、参照や例外のような作用の存在下でも依存型を柔軟にサポートします。
また、{\it ガード型} ({\it guarded types}) と {\it アサート型} ({\it asserting types}) という2つの新しい (馴染みのない) 型を導入することで、{\it ATS} では {\it PTS} よりも柔軟に効果的にプログラムの不変条件を捕捉することができることを示します。

{\it ATS} のデザインと形式化がこの論文の主な主張で、[Zen97,XP99,XCC03] と似たアイデアを使った研究成果です。
{\it ATS} を使うと、{\it PTS} のある種生来の欠陥を乗り越えて、依存型の存在下で多くの一般的なプログラミングの機能をサポートする型システムをたやすく設計できます。
私達は現在 {\it ATS} に基づいた型システムを持ち、(DML で開発されたような) 依存型のみではなく guarded recursive datatypes [XCC03] をもサポートする、型付き関数型プログラミング言語を設計/実装している最中です。
Scheme が導入したようなアプローチ、つまり既存の言語に新しい言語構造を実装するような手法で、{\it ATS} を用いて多様な言語拡張をサポートできないか私達は探求しています。
とりわけ、オブジェクト指向プログラミング [XCC03]、メタプログラミング [XCC03,CX03]、型クラス [XCC02] のようないくつかのプログラミングの機能をこの手法で扱えることを、私達は既に示しています。

論文の残りは次のような構成になっています。
2章では、{\it ATS} フレームワークの詳細な開発成果を示します。
{\it ATS} で構成された汎用的な Applied Type System である ATS を形式化し、それからsubject reductionとprogress定理を定義します。
3章では、{\it ATS} を拡張して、一般帰納、パターンマッチ、作用のような一般的で現実的なプログラミングの機能のいくつかに順応させます。
4章では、applied type system の興味深い例をいくつか示します。
最後に、関連研究と開発の将来の可能性について紹介した後、結論を述べます。
この論文はオンライン [Xi03] から入手できます。

\section{Applied Type System}

この章では Applied Type System ({\it ATS}) フレームワークの形式化を示します。
ここでは {\it ATS} で形式化された型システムを表わすのに {\it applied type system} という用語を使います。
この後の説明では、ATS を静的な要素 (statics) と動的な要素 (dynamics) から成る一般的な applied type system として定義します。
直感的に、statics と dynamics はそれぞれ型とプログラムを扱っています。
単純化のために、statics は簡単な純粋型付き言語であると仮定します。
そしてこの言語の型を {\it 種} ({\it sort}) という名前で呼ぶことにします。
statics の項を {\it 静的な項} ({\it static term}) と呼びます。
また dynamics の項を {\it 動的な項} ({\it dynamic term}) と呼びます。
そして、特別な種 {\it type} の静的な項は dynamics の型として機能します。

\begin{figure}[h]
\centering
\includegraphics[width=11cm]{img/fig1_rules.png}
\caption{staticsを表わすシグニチャフォーマット規則と分類規則}
\label{fig:fig1_rules}
\end{figure}


\subsection{Statics}

静的な要素の形式的な表現を示します。
基礎種を表わすのに {\it b} と書きます。
2つの特別な基礎種 {\it type} と {\it bool} が存在すると仮定します。

\begin{figure}[h]
\centering
\includegraphics[width=9cm]{img/infig21_formaldesc.png}
\end{figure}

静的な項の変数は $\alpha$ を使って表わし、静的な項の集合を $s$ で表わします。
静的な定数 {\it sc} を宣言することもできます。
この定数は、静的な定数コンストラクタ {\it scc} もしくは静的な定数関数 {\it scf} のどちらかです。
sc種 (sc-sorts) を表わすのに [$\sigma_1$, $\ldots$ ,$\sigma_n$] $\Rightarrow$ {\it b} を使い、これは静的な定数に割り当てられます。
静的な定数 {\it sc} が与えられたとき、もし {\it sc} になんらかの種 $\sigma_1$, $\ldots$ ,$\sigma_n$ についてsc種 [$\sigma_1$, $\ldots$ ,$\sigma_n$] $\Rightarrow$ {\it b} が割り当てられていて、$i = 1, \ldots ,n$ について $s_i$ に種 $\sigma_i$ を割り当てることができるなら、種 {\it b} の項 {\it sc}[$s_1$, $\ldots$ ,$s_n$] を作ることができます。
誤解を生じない場合は、{\it sc}[] を {\it sc} と書くことができます。
sc種は (標準の) 種とは見なされていないことに注意してください。

静的な変数を静的な項に写像するような静的な置換を表わすに $\Theta_S$ を使います。
また $\Theta_S$ のドメインを {\bf dom}($\Theta_S$) で表わします。
空の写像を表わすのに [] と書きます。
{\it a} $\notin$ {\bf dom}($\Theta_S$) を仮定したとき、{\it a} から {\it s} へのリンクで $\Theta_S$ を拡張した写像を $\Theta_S$[$a \mapsto s$] と表わします。
また、$\Theta_S$ を構文 $\bullet$ に適用した結果を表わすのに、[$\Theta_S$] と書きます。
構文 $\bullet$ は、静的な項、静的な項の列、この後で定義する動的な可変のコンテキスト、のいずれかを表わします。

シグニチャは宣言された静的な定数 $sc$ に割り当てたsc種を表わし、そのシグニチャの形成ルールは図\ref{fig:fig1_rules}で与えられます。
初期シグニチャ $S_0$ が次の宣言を含むことを仮定しています。

\begin{figure}[h]
\centering
\includegraphics[width=9cm]{img/infig21_initialsig.png}
\end{figure}

\noindent これは、その左側は静的な定数で: その右側には一致するsc種が割り当てられています。
また、それぞれの種 $\sigma$ について、$S_0$ は2つの静的コンストラクタ $\forall_\sigma$ と $\exists_\sigma$ をsc種 [$\sigma \rightarrow_{tp} type$] $\Rightarrow$ {\it type} に割り当てることを仮定しています。
静的な定数を表わすのに中置表記を使うこともできます。
例えば、$\rightarrow_{tp} [s_1,s_2]$ を表わすのに $s_1 \rightarrow_{tp} s_2$ のように、$\leq_{tp} [s_1,s_2]$ を表わすのに $s_1 \leq_{tp} s_2$ のように書けます。
さらに、$\forall_a [\lambda a : \sigma.s]$ と $\exists_a [\lambda a : \sigma.s]$ をそれぞれ $\forall_a : \sigma.s$ と $\exists_a : \sigma.s$ のように書くこともできます。
staticsの分類規則は図\ref{fig:fig1_rules}で与えられますが、大部分は標準的なものです。
例えば、$\emptyset \vdash_{S_0} \forall_{type} [\lambda a : type.a \rightarrow_{tp} a] : type$ が導けるので、$\forall a : type.a \rightarrow_{tp} a$ は種typeを割り当てることができる静的な項です。
なんらかの種 $\sigma_1$, $\ldots$ ,$\sigma_n$ についてsc種 [$\sigma_1$, $\ldots$ ,$\sigma_n$] $\Rightarrow$ {\it type} を割り当てられるなら、静的なコンストラクタ$sc$は型コンストラクタです。
例えば {\bf 1}, $\rightarrow_{tp}$, $\supset$, $\wedge$, $\forall_\sigma$, $\exists_\sigma$ は全て型コンストラクタですが、$\leq_{tp}$ は型コンストラクタではありません。
直感的には、{\bf 1} は通常のユニット型を表わし、$\rightarrow_{tp}$ は関数型を作り、$\leq_{tp}$ は型におけるサブタイピング関係を表わします。
静的なコンストラクタ $\supset$ と $\wedge$ はそれぞれガード型 (guarded types) とアサート型 (asserting types) を作り、これらは後で解説します。

静的な変数群に種を割り当てるような、静的な可変のコンテキストを表わすのに $\Sigma$ を使います;
{\bf dom}($\Sigma$) は $\Sigma$ で宣言された静的な変数の組です;
もし $a : \sigma$ が $\Sigma$ で宣言されていたら、$\Sigma (a) = \sigma$ です。
例によって、$\Sigma$ において静的な変数 $a$ は一回しか宣言できません。
もし $\Sigma \vdash s : bool$ が導けるなら、静的な項 $s$ は $\Sigma$ の下の {\it 命題} ({\it proposition}) と呼ばれます。
(なんらかの静的な可変のコンテキストの下で) 命題を表わすのに $P$ を使います。
$P \supset s$ という形の型を表わすのに {\it ガード型} ({\it guarded type})、$P \wedge s$ という形の型を表わすのに {\it アサート型} ({\it asserting type}) という名前を使います。
これらは両方とも次の例で使います。

\noindent {\it Example 1.}
$int$ を整数
\footnote{形式的には、それぞれの整数 $n$ について、sc種 $[] \Rightarrow int$ の静的なコンストラクタ $\underline n$ が存在し、$\underline n$[] は $n$ に相当する種 $int$ の静的な項であることを言う必要があります。
}
を表わす種に、{\bf list} をsc種 $[type,int] \Rightarrow type$ の型コンストラクタとすると、次の静的な項は型になります:

\begin{figure}[h]
\centering
\includegraphics[width=9cm]{img/infig21_example1_list1.png}
\end{figure}

\noindent 直感的には、もし {\bf list}[$s$,$n$] がそれぞれの要素の型が $s$ で長さ $n$ のリストを表わす型だとすると、リストの長さを変えないようなリストからリストへの関数を上記の型は意図していると言えます。
また次の型は、もし与えられたリストが空でなければそのリストのtailを返し、そうでなければ単に例外を発生させるような関数に割り当てることを意図しています。

\begin{figure}[h]
\centering
\includegraphics[width=11cm]{img/infig21_example1_list2.png}
\end{figure}

アサート型 $n > 0$ $\wedge$ {\bf list}[$a$, $n-1$] は、長さ $n$ のリストにこの関数を適用した後もしこの関数が返るなら、 $n > 0$ であり返値が長さ $n-1$ のリストであるという不変条件を捕捉しています。
これはいくぶん興味深い機能で、このExample 2で詳しく解説します。
Dependent ML [XP99,Xi98] における研究でも既にアサート型がありましたが、
アサート型の正確な概念はこれまで形式化ざれたことがありませんでした:
DMLでは、この論文でアサート型と呼んでいるものをシミュレートするのにサブセット種を使わねばなりませんでした。

{\it PTS} でのデザインと同様に、{\it ATS} でのデザインにおいても型の等価性は難解な問題です。
けれどもさらなる研究によって、{\it ATS} における型の等価性はサブタイピング関係 $\leq_{tp}$ によって定義できることが明らかになりました。
2つの型 $s_1$ と $s_2$ が与えられたとき、もし命題 $s_1 \leq_{tp} s_2$ と命題 $s_2 \leq_{tp} s_1$ の両方が成立するなら、$s_1$ と $s_2$ は等しいと言えるのです。
一般に、(ある前提の元に) 与えられた命題が成立するかどうか決定する必要があります。
そこで、次ような制約関係の概念を導入します。

\begin{figure}[h]
\centering
\includegraphics[width=14cm]{img/fig2_regularity_rules.png}
\caption{規則ルール}
\label{fig:fig2_regularity_rules}
\end{figure}

{\bf Definition 1.}
$S$, $\Sigma$, $\vec{P}$, $P_0$ をそれぞれ 静的なシグニチャ, 静的な可変のコンテキスト, $\Sigma$ の下での命題の組, $\Sigma$ の下での1つの命題であるとします。
もし次の規則条件が満たされるなら、関係 $\Sigma$; $\vec{P} \models_S P_0$ は正規の制約関係であると言います:

\begin{enumerate}
  \item 図\ref{fig:fig2_regularity_rules} の規則ルール全てが有効である; すなわちそれぞれの規則ルールについて、もしルールの根拠が成立するならルールの結論が成立し、なおかつ
  \item $\Sigma; \vec{P} \models_S s_1 \rightarrow_{tp} s_2 \leq_{tp} s'_1 \rightarrow_{tp} s'_2$ は $\Sigma; \vec{P} \models_S s'_1 \leq_{tp} s_1$ と $\Sigma; \vec{P} \models_S s_2 \leq_{tp} s'_2$ を意味し、なおかつ
  \item $\Sigma; \vec{P} \models_S P \supset s \leq_{tp} P' \supset s'$ は $\Sigma; \vec{P},P' \models_S P$ と $\Sigma; \vec{P},P' \models_S s \leq_{tp} s'$ を意味し、なおかつ
  \item $\Sigma; \vec{P} \models_S P \wedge s \leq_{tp} P' \wedge s'$ は $\Sigma; \vec{P},P \models_S P'$ と $\Sigma; \vec{P},P \models_S s \leq_{tp} s'$ を意味し、なおかつ
  \item $\Sigma; \vec{P} \models_S \forall a : \sigma.s \leq_{tp} \forall a : \sigma.s'$ は $\Sigma , a: \sigma; \vec{P} \models_S s \leq_{tp} s'$ を意味し、なおかつ
  \item $\Sigma; \vec{P} \models_S \exists a : \sigma.s \leq_{tp} \exists a : \sigma.s'$ は $\Sigma , a: \sigma; \vec{P} \models_S s \leq_{tp} s'$ を意味し、なおかつ
  \item $\emptyset; \emptyset \models_S scc[s_1,\ldots,s_n] \leq_{tp} scc'[s'_1,\ldots,s'_{n'}]$ は $scc = scc'$ を意味します
\end{enumerate}

\noindent $\Sigma; \vec{P} \models_S P_0$ と書くときはいつでも $P \in \vec{P},P_0$ について $\Sigma \vdash_S P : bool$ を導出できることを仮定していることに注意してください。

\noindent ATSのdynamicsを作るとき、制約関係を必要とします。全ての単一の規則条件と同様に、全ての単一の規則ルールはsubject reduction定理(定理1)とprogress定理(定理2)を規定するために後で使うことになります。
一般に、{\it ATS} フレームワークは制約関係の上にパラメータ化されています。
この時点では、制約関係の決定可能性を気にする必要がありません。
それぞれの制約関係 $\models_S$ について、どのような $\Sigma, \vec{P}$ と $P_0$ が与えられても $\Sigma; \vec{P} \models_S P_0$ が満たされるかどうか、決定してくれるオラクルが存在することを単純に仮定することができます。
後で、制約関係を決定する実用的なアルゴリズムを持つapplied type systemの例をいくつか紹介します。

非叙述性 (impredicativity) のために、与えられたシグニチャ $S$ について制約関係 $\models_S$ を厳密に定義できる方法が一般により難しい問題であることは、強調されるべきです。
[Xi03] では、モデル理論的なアプローチで私達はこの問題を解決しています。


\subsection{Dynamics}

ATS の dynamics は型付き言語で、種 {\it type} の静的な項は dynamics における型です。
動的な定数をいくつか宣言することができ、引数 $n$ の動的な定数 $dc$ それぞれに次の形の dc 型を割り当てることができます。

\begin{figure}[h]
\centering
\includegraphics[width=10cm]{img/infig22_dc-type.png}
\end{figure}

\noindent このとき $s_1,\ldots,s_n,s$ は型であると仮定しています。
$dc$ が動的なコンストラクタ $dcc$ である場合、なんらかの型コンストラクタ $scc$ について 型 $s$ は $scc[\vec{s}]$ の形を取れなければなりません。
すると $dcc$ は $scc$ と関連があると言えるのです。
静的な項の (空である可能性のある) 列を表わすのに $\vec{s}$ を使っていることに注意してください。
例えば、次のようにdc型を割り当てることで、2つの動的なコンストラクタ {\it \underline{nil}} と {\it \underline{cons}} を型コンストラクタ {\bf list} と関連付けることができます。

\begin{figure}[h]
\centering
\includegraphics[width=10cm]{img/infig22_nil_cons.png}
\end{figure}

\noindent このとき、要素の型が $a$ で長さが $n$ のリストを表わす型として {\bf list}$[a,n]$ を使っています。

動的な値を動的な項に写像する動的な置換を $\Theta_D$ で表わします。
また $\Theta_D$ のドメインを {\bf dom}($\Theta_D$) で表わします。
静的な置換と同じように、動的な置換を形成して適用するような構文を示すことを省きます。
{\bf dom}($\Theta^1_D$) $\cap$ {\bf dom}($\Theta^2_D$) $= \emptyset$ となるような $\Theta^1_D$ と $\Theta^2_D$ が与えられたとき、$\Theta^1_D$ と $\Theta^2_D$ の和集合を $\Theta^1_D \cup \Theta^2_D$ で表わします。

任意の構文を $\bullet$ で表わすと、$\Sigma = a_1 : \sigma_1,\ldots,a_k : \sigma_k$ において、$\forall a_1:\sigma_1 \ldots \forall a_k:\sigma_k .\bullet$ を $\forall\Sigma.\bullet$ と書くことができます。
同様に、$\vec{P} = P_1,\ldots,P_m$ において $P_1 \supset (\ldots(P_m \supset \bullet)\ldots)$ を $\vec{P} \supset \bullet$ と書くことができます。
例えば、dc型は常に $\forall \Sigma.\vec{P} \supset ([s_1,\ldots,s_n] \Rightarrow_{tp} s)$ の形になります。
動的な定数の宣言を許可するために、シグニチャの定義を次のように拡張する必要があります。

\begin{figure}[h]
\centering
\includegraphics[width=9cm]{img/infig22_dynamic_sig.png}
\end{figure}

\noindent さらに、シグニチャを作るために次のような追加のルールが必要になります。

\begin{figure}[h]
\centering
\includegraphics[width=9cm]{img/infig22_addtional_rule.png}
\end{figure}

\noindent 動的な項の変数として $x$ を、動的な項として $d$ を用いるとき、dynamicsの構文を図\ref{fig:fig3_syntax_dynamics} に示します。
引数の個数が $n$ の動的な定数 $dc$ が与えられたとき、引数 $d_1,\ldots,d_n$ への $dc$ の適用を $dc[d_1,\ldots,d_n]$ と書きます。
$n = 0$ の場合には $dc[]$ の代わりに $dc$ と書くこともできます。

\begin{figure}[h]
\centering
\includegraphics[width=14cm]{img/fig3_syntax_dynamics.png}
\caption{dynamicsの構文}
\label{fig:fig3_syntax_dynamics}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=8cm]{img/fig4_rules_dynamics.png}
\caption{動的な可変のコンテキストを表わす形成ルール}
\label{fig:fig4_rules_dynamics}
\end{figure}

型の導出において帰納的な意味付けに必要なLemma 3を証明するために、標識 $\supset^+(\cdot)$, $\supset^-(\cdot)$, $\wedge(\cdot)$, $\forall^+(\cdot)$, $\forall^-(\cdot)$, $\exists(\cdot)$ を導入します。
これらの標識がないと、型の導出において帰納的証明を行なうことが、著しく困難になります。
Lemma 3を証明することも困難になってしまうでしょう。

$\Sigma \vdash_S \Delta [dctx]$ の形の判定は、$\Sigma$ と $S$ の下で $\Delta$ が well-formed な動的な可変のコンテキストであることを示しています。
このような判定を導出するルールを図\ref{fig:fig4_rules_dynamics}に示します。
型付けされたコンテキトを $\Sigma; \vec{P}; \Delta$ で表わします。
次のルールは $\vdash_S \Sigma; \vec{P}; \Delta$ の形の判定を導出しています。

\begin{figure}[h]
\centering
\includegraphics[width=7cm]{img/infig22_rule_deriving.png}
\end{figure}

\noindent これは $\Sigma; \vec{P}; \Delta$ が well-formed であることを示しています。

xxx

\begin{figure}[h]
\centering
\includegraphics[width=9cm]{img/infig22_ty-var.png}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=9cm]{img/infig22_example2.png}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=9cm]{img/infig22_letin.png}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=9cm]{img/infig22_eval.png}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=12cm]{img/fig5_typingrules_dynamics.png}
\caption{dynamicsの型付けルール}
\label{fig:fig5_typingrules_dynamics}
\end{figure}

xxx

\subsection{型消去済の動的な項}

動的な項から、意味論を維持した型無しのラムダ式に変換する関数を示します。
次のように形式的に定義された型消去済の動的な項を $e$ で表わします:

\begin{figure}[h]
\centering
\includegraphics[width=13cm]{img/infig3_erasure.png}
\end{figure}

\noindent すると、動的な項から型消去済の動的な項への変換する、次のような関数 $|\cdot|$ を定義できます。

\begin{figure}[h]
\centering
\includegraphics[width=12cm]{img/infig3_trans_erasure.png}
\end{figure}

\noindent {\bf Theorem 3.}
$D :: \emptyset; \emptyset; \emptyset \vdash_S d : s$ を仮定したとき

\begin{enumerate}
  \item もし $d \hookrightarrow^* v$ ならば $|d| \hookrightarrow^* |v|$ です。
  \item もし $|d| \hookrightarrow^* w$ ならば $d \hookrightarrow^* v$ かつ $|v| = w$ であるような値 $v$ が存在します。
\end{enumerate}

\noindent {\it Proof.}
(1) は自明です。(2) は $D$ に対する構造帰納法から得られます。

\noindent Theorem 3 を用いると、型消去済の動的な項 $d$ を単純に評価することで、動的な項 $d$ を評価することができます。

\section{拡張}

xxx

\section{Applied Type Systemの例}

驚くことではありませんが、$\lambda$-cube [Bar92] における System $\lambda_2$ と $\lambda_{\omega}$ が applied type system であることは簡単に示すことができます。
また guarded recursive datatypes で $\lambda_2$ を拡張した $\lambda_{G\mu}$ 言語 [XCC03] と Dependent ML [XP99] も applied type system です。
より詳細な説明は [Xi03] を参照してください。

\section{関連研究と結論}

{\it ATS} フレームワークは、依存データ型を使って ML の型システムを改良した Dependent ML [XP99,Xi98] と、最新の研究である guarded recursive datatypes [XCC03] の成果に基づいています。
これら2つの型
\footnote{実際には guarded recursive datatypes を、型が型をインデックスするような "依存型" として考えることができます。}
の間に類似点を見つけた私達は、自然にこれらの統一された表現の探求に導かれました。

Haskellの型クラスの根底にある qualified types [Jon94] に精通した人に対して、qualified type はガード型と見なせないことを指摘しておきます。
その単純な理由は、applied type system におけるガードの証明が計算上の意味を持っていないことです。
つまり、プログラムの実行時の挙動に影響を及ぼすことができないのです。
しかし、qualified types の環境における型の述語の証明である dictionary はプログラムの実行時の挙動に影響を与えることができ、また好んで使われます。

別方向の関連研究として certified binaries [SSTP02] を用いた型システムの形式化があります。
これもまた型とプログラムを完全に分離するアイデアです。
帰納的な定義 (CiC) [PPM89,PM93] を拡張した calculus of constructions にこの型言語は基づいているとはいえ、基本的にこの型システムにおける型言語と計算言語の概念は、それぞれATSのstaticsとdynamicsの概念に相当します。
けれども、ATS における制約関係の概念は [SSTP02] のものに相当するわけではありません。
その代わりに、型の正規形を比較することで、2つの型の等価性を決定できます。
私達が applied type system と関連した制約関係の証明を効果的に表現/検証するアプローチ持っている以上、[SSTP02] の意味での certify binaries に対して applied type system を構築することも困難ではありません。

要約すると、実用的なプログラミングをサポートするための型システムのデザインと形式化を促進するために、{\it ATS} フレームワークを示しました。
statics と dynamics を完全に分離することで、{\it ATS} は作用の存在下における依存型のサポートに特に威力を発揮します。
また、{\it ATS} のガード型とアサート型を使うことで、より柔軟により効果的にプログラムの不変条件を捕捉できます
これまで研究されてきた依存型 [XP99,Xi98] と guarded recursive datatypes [XCC03] の統一化と一般化であると {\it ATS} をとらえることもできます。

現時点では {\it ATS} の静的な要素は単純なラムダ計算に基づいています。
従って、静的な要素が多相性と依存型をサポートする型付きラムダ計算の上に構築できるか研究することができるでしょう。
また、{\it ATS} に基づく型システムを使って関数型プログラミング言語をデザイン/実装することに、私達は特に興味を持っています。
それは既存の言語において新しい言語構造を実装ような方法で、言語拡張を行なう手段を提供できるでしょう。

\begin{acknowledgment}
Assaf Kfouryから本論文のドラフトに対するコメントをもらいました。
また、Chiyan Chenとは本論文の主題について議論しました。
感謝します。
\end{acknowledgment}

%\begin{thebibliography}{10}
%\end{thebibliography}

\end{document}
