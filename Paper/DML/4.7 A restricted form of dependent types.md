[](- 4.7 A restricted form of dependent types)

- 4.7 依存型の制限された形

	Generally speaking, we use the name dependent types to refer to a form of types that correspond to formulas in some first-order many-sorted logic.
	For instance, the following type in λΠ,Σ pat :

	一般的に言えば、我々はいくつかの一次の多くのソートロジックで式に対応種類のフォームを参照するために名前依存型を使用します。
	例えば、λΠに次のように入力し、Σパット：

		Πa:int. a ≥ 0 ⊃ (int(a) → int(a + a))

	corresponds to the following first-order formula:

	以下の一次式：

		∀a : int.a ≥ 0 ⊃ (int(a) → int(a + a))

	where int is interpreted as some predicate on integers, and both ⊃ and → stand for the implication connective in logic.
	However, it is not possible in λΠ,Σ pat to form a dependent type of the form Πa : τ1. τ2, which on the other hand is allowed in a

	どこのintは整数に対するいくつかの述語として解釈され、両方⊃と→ロジックにおける含意結合放置されている。
	τ1：しかし、それはλΠでは不可能である、Σのパットは、フォームπAの依存型を形成する。一方で許可されているτ2、

		expressions e ::= x | c(e) | case e of (p1 ⇒ e1 | ... pn ⇒ en) |
		<> | <e1, e2> | fst(e) | snd(e) |
		lam x. e | lamx : τ. e | e1(e2) |
		fix f : τ. e | let x = e1 in e2 end |
		λa : sˆ. e | e[I] | (e : τ )
	
	[](Fig. 20. The syntax for DML0)

	図20. DML0構文

	(full) dependent type system such as λP (Barendregt, 1992).
	To see the difficulty in supporting practical programming with such types that may depend on programs, let us recall the following rule that is needed for determining the static subtype relation ≤s tp in λΠ,Σ pat :

	そのようなλP（Barendregt、1992）など（フル）依存型システム。
	我々はλΠ、ΣのパットでTP≤s静的サブタイプ関係を決定するために必要とされる以下のルールを思い出してみましょう、プログラムに依存してもよいような種類の実用的なプログラミングをサポートするのが困難を表示するには：

		φ; P~ |= I .= I'
		-------------------------
		φ; P~ |= δ(I) ≤stp δ(I') 

	If I and I' are programs, then I .= I' is an equality on programs.
	In general, if recursion is allowed in program construction, then it is not just undecidable to determine whether two programs are equal; it is simply intractable.
	In addition, such a design means that the type system of a programming language can be rather unstable as adding a new programming feature into the programming language may significantly affect the type system.
	For instance, if some form of effect (e.g., exceptions, references) is added, then equality on programs can at best become rather intricate to define and is in general impractical to reason about.
	Currently, there are various studies aiming at addressing these difficulties in order to support full dependent types in practical programming.
	For instance, a plausible design is to separate pure expressions from potentially effectful ones by employing monads and then require that only pure expressions be used to form types.
	As for deciding equalities on (pure) expressions, the programmer may be asked to provide proofs of these equalities.
	Please see (McBride, n.d.; Westbrook et al., 2005) for further details.

	私と私は場合はプログラム上の等価性は '私。=私は、プログラムです」。
	再帰プログラム構築に許可されている場合、一般的に、それは2つのプログラムが等しいかどうかを判断するだけでは決定不能ではない。それは単に難治性である。
	また、このような設計は、プログラミング言語の型システムが大幅型システムに影響を与える可能性がプログラミング言語に新しいプログラミング機能を追加するなど、むしろ不安定になることができることを意味する。
	効果（例えば、例外、参考文献）のいくつかのフォームが追加された場合、インスタンスの場合は、プログラム上のその後等価性は、せいぜい定義するのではなく複雑ななることができ、一般的には約理由に非現実的である。
	現在、実用的なプログラミングに完全に依存するタイプをサポートするために、これらの問題に対処することを目指して様々な研究がある。
	例えば、妥当な設計がモナドを使用することによって、潜在的に副作用のものから純粋な表現を分離することで、次に純粋な式が型を形成するために使用されることを必要とする。
	（純粋）式に等式を決定するため、プログラマはこれらの等式の証明を提供するために求められることがあります。
	（マクブライド、NDを、ウェストブルックら、2005。）を参照してください詳細については。

	----
	
	[](
	We emphasize that the issue of supporting the use of dependent types in practical programming is largely not shared by Martin-L¨of’s development of constructive type theory (Martin-L¨of, 1984; Martin-L¨of, 1985), where the principal objective is to give a constructive foundation of mathematics.
	In such a pure setting, it is perfectly reasonable to define type equality in terms of equality on programs (or more accurately, proofs).
	)

	我々は強調し、その大部分は建設的な型理論のマーティン-LOFの開発によって共有されていない実用的なプログラミングの依存型の使用をサポートの問題（マーティン-LOF、1984、マーティン-LOF、1985）、ここで、主な目的は、数学の建設的な基礎を提供することです。
	純粋な設定では、タイプのプログラム上の等価性の観点から等価（またはより正確に、プルーフ）を定義することは完全に合理的である。
