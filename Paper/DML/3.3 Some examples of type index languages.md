[](# 3.3 Some examples of type index languages)

# 3.3 型インデックス言語のいくつかの例

[](- 3.3.1 A type index language Lalg)
- 3.3.1 型インデックス言語 Lalg


	[](
	We now describe a type index language Lalg in which only algebraic terms can be formed .
	Suppose that there are some base sorts in Lalg .
	For each base sort b, there exists some constructors of c-sorts (b1, ..., bn) ⇒ b for constructing terms of the base sort b, and we say that these constructors are associated with the sort b .
	In general, the terms in Lalg can be formed as follows, index terms I ::= a | C(I1, ..., In) where C is a constructor or an equality constant function .=s for some sort s .
	For instance, we may have a sort Nat and two constructors Z and S of c-sorts () ⇒ Nat and (Nat) ⇒ Nat, respectively, for constructing terms of sort Nat .
	A constraint in Lalg is of the following form :
	)
	
	私たちは、今だけの代数の用語が形成可能なタイプインデックス言語Lalgについて説明します。
	Lalgにおけるいくつかの基本種類があることとします。
	各ベースソートBについて、C-種類のいくつかのコンストラクタが存在する（b1は、...、BN）は、基本ソートbのの項を構築するため、B。⇒、と我々はこれらのコンストラクタは種Bと関連していると言う。
	一般的に、Lalgにおける用語は、私が:: =、次のように索引語を形成することができる| C（I1、...、IN）、Cはコンストラクタまたは等価性定数関数であるいくつかの並べ替えsの= sの。。
	例えば、我々は、ソートのc-種類のNATと二つのコンストラクタZとS（）はナット⇒と（NAT）は、それぞれNATは、ソートナットのの項を構築するために、⇒持っている場合があります。
	Lalgにおける制約は、以下の形式は次のとおりです。

		a1 : b1, ..., an : bn; I1 .= I 0 1 , ..., In .= I 0 n |= I .= I 0

	[](
	where each .= is .=s for some sort s.
	A simple rule-based algorithm for solving this kind of constraints can be found in (Xi et al., 2003), where algebraic terms are used to represent types.
	)

	ここで、各。=である。いくつかの並べ替えsの= sの。
	制約のこの種を解決するための単純なルールベースのアルゴリズムを見つけることができ（西ら、2003）、代数的用語は型を表すために使用される場合。

	----

	[](
	In practice, we can provide a mechanism for adding into Lalg a new base sort b as well as the constructors associated with b.
	As an example, we may use the following concrete syntax:
	)

	実際には、我々はLalgに新しい基地ソートbと同様にaと関連するコンストラクタを追加するための機構を提供することができる。
	例として、以下の具体的な構文を使用することがあります：

		datasort stp =
		Bool | Integer | Arrow of (stp, stp) | Pair of (stp, stp)

	[](to introduce a sort stp and then associate with it some constructors of the following c-sorts:)

	以下のc-sortのいくつかのコンストラクタを種 stpを導入し、それに関連付ける：

		Bool : () ⇒ stp
		Integer : () ⇒ stp
		Arrow : (stp, stp) ⇒ stp
		Pair : (stp, stp) ⇒ stp

	[](
	We can then use index terms of the sort stp to represent the types in a simply typed λ-calculus where tuples are supported and there are also base types for booleans and integers.
	In Section 7.3, we will present a concrete programming example involving the type index language Lalg .
	)
	タプルはサポートされており、ブール値と整数のベースタイプもあるされる場合我々は、単に入力されたλ計算で型を表現するために種STPの索引語を使用することができます。
	7.3節では、タイプインデックス言語Lalgを含む具体的なプログラミング例を紹介します。

[](- 3.3.2 Another type index language Lint)
- 3.3.2 他の型インデックス言語 Lint

	[](
	We now formally describe another type index language Lint in which we can form integer expressions.
	The syntax for Lint is given as follows:
	)
	私たちは今、正式に私たちは整数式を形成することができる別のタイプのインデックス言語リントを記述する。
	次のように糸くずの構文は、次式で与えられます。

		index sorts s ::= bool | int
		index terms I ::= a | C(I1, ..., In)
	
	[](
	There are no tuples and functions (formed through λ-abstraction) in Lint, and the constants C in Lint together with their c-sorts are listed in Figure 10.
	Let Dint be the domain (set) of integers and Mint be h{Dbool , Dint}, Iinti, where Iint maps each constant in Lint to its standard interpretation.
	For instance, I(+) and I(−) are the standard addition and subtraction functions on integers, respectively.
	It can be readily verified that Mint is a model for Lint. Therefore, the constraint relation |=Mint is regular.
	)

	図10に記載されていないタプルや糸くずの関数（λ-抽象化を通じて形成される）、そして一緒にC-種類と糸くずの定数Cはありません。
	Dintは、整数のドメイン（セット）であるとミントがIINTが標準解釈に糸くずの各定数をマップH{Dbool、Dintを}、Iinti、とする。
	例えば、私（+）とI（ - ）はそれぞれ、整数上の標準加算と減算関数です。
	それは容易にミントリントのためのモデルであることを検証することができる。そのため、制約関係は|=ミントは正則で。

		true : () → bool
		false : () → bool
		i : () → int for every integer i
		¬ : (bool) → bool negation
		∧ : (bool, bool) → bool conjunction
		∨ : (bool, bool) → bool disjunction
		+ : (int, int) → int
		− : (int, int) → int
		: (int, int) → int
		/ : (int, int) → int
		max : (int, int) → int
		min : (int, int) → int
		mod : (int, int) → int modulo operation
		≥ : (int, int) → bool
		> : (int, int) → bool
		≤ : (int, int) → bool
		< : (int, int) → bool
		= : (int, int) → bool
		6= : (int, int) → bool
		... : ...

	[](Fig. 10. The constants and their c-sorts in Lint)
	図10. 定数とLintでのc-sorts

		datasort typ = Arrow of (typ, typ) | All of (typ -> typ)
		datatype EXP (typ) =
		| {a1:typ, a2:typ} EXPlam (Arrow (a1, a2)) of (EXP (a1) -> EXP (a2))
		| {a1:typ, a2:typ} EXPapp (a2) of (EXP (Arrow (a1, a2)), EXP (a1))
		| {f:typ -> typ} EXPalli (All (f)) of ({a:typ} EXP (f a))
		| {f:typ -> typ,a:typ} EXPalle (f a) of (EXP (All f))

	[](Fig. 11. An example involving higher-order type index terms)
	図11. 高階型インデックス項を含む例

	[](
	Given a constraint φ; P~ |=Mint P0, where φ = a1 : int, ..., an : int, and each P in P~ is a linear inequality on integers, and P0 is also a linear inequality on integers, we can use linear integer programming to solve such a constraint.
	We will mention later that we can make use of the type index language Lint in the design of a dependently type functional programming language where type equality between two types can be decided through linear integer programming.
	Though the problem of linear integer programming itself is NP-complete, we have observed that the overwhelming majority of constraints encountered in practice can be solved in a manner that is efficient enough to support realistic programming.
	)

	制約φを考える。 P〜|=ミントP0、どこに、φ=のA1：int型、。 。 。 、：int型、およびP〜の各Pは整数に対する線形不等式であり、P0は、我々はそのような制約を解決するために、線形整数計画を使用することができ、また、整数上の線形不等式です。
	我々はの設計タイプインデックス言語リントを利用することができ、後に言及します依存して二種類のタイプの平等は線形整数計画を経て決定することができる機能的なプログラミング言語を入力します。
	線形整数計画自体の問題は、NP完全であるが、我々は、実際に遭遇する制約の圧倒的多数は、現実的なプログラミングをサポートするのに十分に効率的な方法で解決することができることを観察した。

[](- 3.3.3 Higher-order type index terms)
- 3.3.3 高階段型インデックス項

	[](
	There are no higher-order type indexes, that is, type index terms of function sorts, in either Lalg or Lint.
	In general, the constraint relation involving higher-order type indexes are often difficult or simply intractable to solve.
	We now present a type index language Lλ, which extends Lalg with higher-order type indexes as follows:
	)

	高階型インデックス、つまり、LalgやLintのどちらかの関数種の型インデックス項は全くありません。
	一般に、高階型インデックスに関連する制約関係は、しばしば困難または解決することが簡単に扱うことが出来ません。
	我々は現在、次のように高階型インデックスとLalgを拡張タイプインデックス言語Lλを提示します:

		index terms I ::= ... | λa : s.I | I1(I2)

	[](
	Like in Lalg , a constraint in Lλ is of the following form:
	)

	Lalgのように、Lλでの制約は以下の形式になります。

		a1 : b1, ..., an : bn; I1 .= I 0 1 , ..., In .= I 0 n |= I .= I 0

	[](
	For instance, we may ask whether the following constraint holds:
	)

	たとえば、我々は以下の制約が成立するかどうかを求める場合があります:

		a1 : b → b, a2 : b; a1(a1(a2)) .= a1(a2) |= a1(a2) = a2

	aaaaaaaaaaa

	[](
	If there are two distinct constants C1 and C2 of sort b, then the answer is negative since a counterexample can be constructed by letting a1 and a2 be λa : b.C1 and C2, respectively.
	Clearly, the problem of solving constraints in Lλ is undecidable as (a special case of) it can be reduced to the problem of higher-order unification.
	For instance, φ; I1 .= I2 |= false holds if and only if there exists no substitution Θ : φ such that I1[Θ] and I2[Θ] are βη-equivalent.
	)

	それぞれ、b.C1及びC2：つの異なる定数C1とソートbのC2がある場合反例をa1とa2をλaとすることがせることによって構築することができるので、答えは否定的である。
	（特別な場合）には高次の統一の問題に還元することができるように明確に、Lλに制約を解決する問題が決定不能である。
	例えば、φ。 I1= I2|=全く代替Θが存在しないとする場合にのみ場合はfalseが成り立つ：。そのようなφI1[Θ]とI2[Θ]はβη等価であること。

	----

	[](
	In practice, we can decide to only handle constraints of the following simplified form:
	)

	実際には、我々は唯一以下の簡略化した形の制約を処理するために決定することができます。

		φ; a1.= I1, ..., an.= In |= I.= I0

	[](
	where for 1 ≤ i ≤ j ≤ n, there are no free occurrences of aj in Ii.
	Solving such a constraint can essentially be reduced to deciding the βη-equality on two simply typed λ-terms, which is done by comparing whether the two λ-terms have the same long βη-normal form.
	)

	1≤のために、私はJの≤nを≤場所、井伊でAJの空き出現はありません。
	解決そのような制約は、基本的に2つのλ-用語が同じ長いβη-正規形を持っているかどうかを比較することによって行われている2単に入力されたλ-条件でβη-平等を、決定に還元することができる。

	----

	[](
	We now present an example that makes use of higher-order type indexes.
	The constraints on type indexes involved in this example have the above simplified form and thus can be easily solved using βη-normalization.
	The concrete syntax in Figure 11 declares a sort typ and a type constructor EXP that takes an index term I of sort typ to form a type EXP(I).
	The value constructors associated with EXP are assigned the following c-types:
	)

	我々は現在、高次タイプのインデックスを利用した例を提示する。
	この例では、関連するタイプのインデックスに対する制約は、上記の簡略化した形態を有し、したがって、容易にβη正規化を使用して解くことができる。
	図11の具体的な構文は、ソートTYPとタイプEXP（I）を形成するために、一種の標準索引用語Iをとり型コンストラクタのEXPを宣言します。
	EXPに関連付けられた値コンストラクタは、次のC-タイプが割り当てられています。

		EXPlam : Πa1 :typ.Πa2 :typ.
			(EXP(a1) → EXP(a2)) ⇒ EXP(Arrow(a1, a2))
		EXPapp : Πa1 :typ.Πa2 :typ.
			(EXP(Arrow(a1, a2)), EXP(a1)) ⇒ EXP(a2)
		EXPalli : Πf :typ → typ.
			(Πa:typ. EXP(f(a))) ⇒ EXP(All(f))
		EXPalle : Πf :typ → typ.Πa:typ.
			(EXP(All(f))) ⇒ EXP(f(a))

	[](
	The intent is to use an index term I of sort typ to represent a type in the secondorder polymorphic λ-calculus λ2 (a.k.a. system F), and a value of type EXP(I) to represent a λ-term in λ2 that can be assigned the type represented by I.
	For instance, the type ∀α. α → α is represented as All(λa : typ. Arrow(a, a)), and the following term:
	)

	意図ができλ2におけるλ期を表現するためにsecondorder多型λ計算のλ2（別名システムF）を入力し、タイプEXP（I）の値を表すために、一種の標準索引用語Iを使用することですIで表さタイプが割り当て
	例えば、タイプの∀α。 α→αはすべてのように表される（λaは：。TYP矢印（、a）参照）、および以下の言葉を。

		EXPalli(Π+(EXPalli(Π+(EXPlam(lamx. EXPlam(lamy. EXPapp(y, x)))))))

	----


		types τ ::= ... | δ(
		~I) | P ⊃ τ | P ∧ τ | Πa:s. τ | Σa:s. τ
		expressions e ::= ... | ⊃
		+(v) | ⊃
		−(e) | Π
		+(v) | Π
		−(e) |
		∧(e) | let ∧ (x) = e1 in e2 end |
		Σ(e) | let Σ(x) = e1 in e2 end
		values v ::= ... | ⊃
		+(v) | Π
		+(v) | ∧(v) | Σ(v)

	[](Fig. 12. The syntax for λΠ,Σ pat)
	図12. λΠ,Σ pat用構文

	[](
	which can be given the following type:
	)

	これは、次の型を与えることができる：

		EXP(All(λa1 : typ. All(λa2 : typ. Arrow(a1, Arrow(Arrow(a1, a2), a2)))))

	[](
	represents the λ-term Λα1.Λα2.λx : α1.λy : α1 → α2.y(x).
	This is a form of higherorder abstract syntax (h.o.a.s.) representation for λ-terms (Church, 1940; Pfenning & Elliott, 1988; Pfenning, n.d.).
	As there is some unfamiliar syntax involved in this example, we suggest that the reader revisit it after studying Section 4.
	)

	λ長期Λα1.Λα2.λxが表す：α1.λy：α1は→α2.y（X）。
	これはλ-用語（;プフェニング＆エリオット、1988;プフェニング、ND教会、1940）のためのhigherorder抽象構文（のHoA）表現の一形態です。
	この例に関わるいくつかのなじみのない構文があるように、我々は読者が第4節を勉強した後にそれを再検討することを示唆しています。
