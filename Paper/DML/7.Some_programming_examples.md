- 7 Some programming examples

	We have finished prototyping a language Dependent ML (DML), which essentially extends ML with a form of dependent types in which type index terms are drawn from the type index languages Lint and Lalg presented in Section 3.3.2 and Section 3.3.1, respectively.

	At this moment, DML has already become a part of ATS, a programming language with a type system rooted in the framework Applied Type System (Xi, 2004).

	The current implementation of ATS is available on-line (Xi, 2005), which includes a type-checker and a compiler (from ATS to C) and a substantial library (containing more than 25K lines of code written in ATS itself).

	When handling integer constraints, we reject nonlinear ones outrightly rather than postpone them as hard constraints (Michaylov, 1992), which is planned for future work.

	This decision of rejecting nonlinear integer constraints may seem ad hoc, and it can be too restrictive, sometimes, in a situation where nonlinear constraints (e.g., ∀n : int. n ∗ n ≥ 0) need to be dealt with.

	To address this issue, an approach to combining programming with theorem proving has been proposed recently (Chen & Xi, 2005a).

	If the constraints are linear, we negate them and test for unsatisfiability.

	For instance, the following is a sample constraint generated when an implementation　of binary search on arrays is type-checked:

		φ; P~ |= l + (h − l)/2 + 1 ≤ sz
		where
		φ = h : int, l : int, sz : int
		P~ = l ≥ 0, sz ≥ 0, 0 ≤ h + 1, h + 1 ≤ sz, 0 ≤ l, l ≤ sz, h ≥ l

	The employed technique for solving linear constraints is mainly based on the FourierMotzkin variable elimination approach (Dantzig & Eaves, 1973), but there are many other practical methods available for this purpose such as the SUP-INF method (Shostak, 1977) and the well-known simplex method.

	We have chosen FourierMotzkin’s method mainly for its simplicity.

	We now briefly explain this method.

	We use x for integer variables, a for integers, and l for linear expressions.

	Given a set of inequalities S, we would like to show that S is unsatisfiable.

	We fix a variable x and transform all the linear inequalities into one of the two forms: l ≤ ax and ax ≤ l, where a ≥ 0 is assumed.

	For every pair l1 ≤ a1x and a2x ≤ l2, where a1, a2 > 0, we introduce a new inequality a2l1 ≤ a1l2 into S, and then remove from S all the inequalities involving x.

	Clearly, this is a sound but incomplete procedure.

	If x were a real variable, then the procedure would also be complete.

	In order to handle modulo arithmetic, we also perform another operation to rule out non-integer solutions: we transform an inequality of form

		a1x1 + · · · + anxn ≤ a

	Recently,, we have also implemented a constraint solver based the simplex method.

	Our experience indicates that Fourier-Motzkin’s method is almost always superior to the the simplex method due to the nature of the constraints encountered in practice.

		into a1x1 + · · · + anxn ≤ a0,
		where a
		0
		is the largest integer such that a
		0 ≤ a and the greatest common divisor
		of a1, . . . , an divides a
		0.

	The method can be extended to become both sound and complete while remaining practical (see, for example, (Pugh & Wonnacott, 1992; Pugh & Wonnacott, 1994)).

	In DML, we do allow patterns in a matching clause sequence to be overlapping, and sequential pattern matching is performed at run-time.

	This design can lead to some complications in type-checking, which will be mentioned in Section 7.2.

	Please refer to (Xi, 2003) for more details on this issue.
	
	We now present some programing examples taken from a prototype implementation of DML, giving the reader some concrete feel as to how dependent types can actually be used to capture programming invariants in practice.

- 7.1 Arrays

	Arrays are a widely used data structure in practice.

	We use array as a built-in type constructor that takes a type τ and a natural number n to form the type (τ )array(n) for arrays of size n in which each element has the type τ.

	We also have the built-in functions sub, update and make, which are given the following c-types:

		sub : ∀α.Πn:nat.Πi:{a : nat | a < n}. (α)array(n) ∗ int(i) ⇒ α
		update : ∀α.Πn:nat.Πi:{a : nat | a < n}. (α)array(n) ∗ int(i) ∗ α ⇒ 1
		make : ∀α.Πn:nat. int(n) ∗ α ⇒ (α)array(n)

	There is no built-in function for computing the size of an array.

	Notice that the c-type of sub indicates that the function can be applied to an array and an index only if the value of the index is a natural number less than the size of the array.

	In other words, the quantification Πn : nat.Πi : {a : nat | a < n} acts like a precondition for the function sub.

	The c-type of update imposes a similar requirement.

	We may, however, encounter a situation where the programmer knows or believes for some reason that the value of the index is within the bounds of the array, but this property is difficult or even impossible to be captured in the type system of DML.

	In such a situation, the programmer may need to use run-time array bound checks to overcome the difficulty. We now present some type-theoretical justification for run-time array bound checking in DML.

	In Figure 28, we declare a type constructor Array for forming types for arrays with size information.

	The only value constructor Array associated with the type constructor Array is assigned the following c-type:

		∀α.Πn:nat. int(n) ∗ (α)array(n) ⇒ (α)Array(n)

	The defined functions arraySub, arrayUpdate and makeArray correspond to the 3 Each valid index of an array is a natural number less than the size of the array datatype ’a Array with nat = {n:nat} Array(n) of int(n) * ’a array(n) exception Subscript

		fun(’a) arraySub (Array(n, a), i) =
		if (i < 0) then raise Subscript
		else if (i >= n) then raise Subscript
		else sub (a, i)
		withtype {n:nat,i:int} ’a Array(n) * int(i) -> ’a
		fun(’a) arrayUpdate (Array(n, a), i, x) =
		if (i < 0) then raise Subscript
		else if (i >= n) then raise Subscript
		else update (a, i, x)
		withtype {n:nat,i:int} ’a Array(n) * int(i) * ’a -> unit
		fun(’a) makeArray (n, x) = Array (n, make (n, x))
		withtype {n:nat} int(n) * ’a -> ’a Array(n)
		fun(’a) arrayLength (Array(n, _)) = n
		withtype {n:nat} ’a Array(n) -> int(n)

		Fig. 28. A datatype for arrays with size information and some related functions

	functions sub, update and make, respectively.

	Note that run-time array bound checks are inserted in the implementation of arraySub and arrayUpdate.

	For an array carrying size information, the function arrayLength simply extracts out the information.

	Additional examples can be found in (Xi & Pfenning, 1998) that makes use of dependent types in eliminating run-time array bound checks.

	Clearly, the programmer now has the option to decide which subscripting (updating) function should be used: sub or arraySub (update or arrayUpdate)?

	When compared to the former, the latter is certainly less efficient and may incur a runtime exception.

	However, in order to use the former, the programmer often needs to capture more program invariants by supplying type annotations.

	This point is shown clearly when we compare the two (essentially identical) implementations of the standard binary search on integer arrays in Figure 29.

	In the first implementation, we use the array subscripting function arraySub, which incurs run-time array bound checks.

	In the second implementation, we instead use sub, which incurs no run-time array bound checks.

	Clearly, the second implementation is superior to the first one when either safety or efficiency is of the concern.

	However, the programmer needs to provide a more informative type for the inner function loop in order to eliminate the array bound checks.

	In this case, the provided type captures the invariant that i ≤ j +1 ≤ n holds whenever loop is called, where i and j are integer values of l and u, respectively, and n is the size of the array being searched.
	
		datatype ORDER = LESS | EQUAL | GREATER
		fun binarySearch cmp (key, Vec) = let (* require run-time bound checks *)
		fun loop (l, u) =
		if u < l then NONE
		else let
		val m = l + (u-l) / 2
		val x = arraySub (Vec, m) (* require bound checks *)
		in case cmp (x, key) of
		LESS => loop (m+1, u)
		| GREATER => loop (l, m-1)
		| EQUAL => SOME (m)
		end
		withtype int * int -> int option
		in loop (0, length Vec - 1) end
		withtype {n:nat} (’a * ’a -> Bool) -> (’a * ’a Array(n)) -> int option
		fun binarySearch cmp (key, Vec) = let (* require NO run-time bound checks *)
		val Array (n, vec) = Vec
		fun loop (l, u) =
		if u < l then NONE
		else let
		val m = l + (u-l) / 2
		val x = sub (vec, m) (* require no bound checks *)
		in case cmp (x, key) of
		LESS => loop (m+1, u)
		| GREATER => loop (l, m-1)
		| EQUAL => SOME (m)
		end
		withtype {i:nat,j:int | i <= j+1 <= n} int(i) * int(j) -> int option
		in loop (0, n-1) end
		withtype {n:nat} (’a * ’a -> Bool) -> (’a * ’a Array(n)) -> int option

		Fig. 29. Two implementations of binary search on integer arrays in DML

- 7.2 Red-black trees

	We now show a typical use of dependent types in capturing certain inherent invariants in data structures.

	A red-black tree (RBT) is a balanced binary tree that satisfies the following conditions:

	1. All leaves are marked black and all other nodes are marked either red or black;
	2. for every node there are the same number of black nodes on every path connecting the node to a leaf, and this number is called the black height of the node;
	3. the two children of every red node are black.

	It is a common practice to use the RBT data structure to implement a dictionary.

	We declare a datatype in Figure 30, which precisely captures the above three properties of being a RBT.

		sort color = {a:int | 0 <= a <= 1} (* sort declaration *)
		datatype ’a rbtree (color, nat, nat) = (* color, black height, violation *)
		E(0, 0, 0)
		| {cl:color, cr:color, bh:nat}
		B(0, bh+1, 0) of ’a rbtree(cl, bh, 0) * ’a * ’a rbtree(cr, bh, 0)
		| {cl:color, cr:color, bh:nat}
		R(1, bh, cl+cr) of ’a rbtree(cl, bh, 0) * ’a * ’a rbtree(cr, bh, 0)
		fun restore (R(R(a, x, b), y, c), z, d) = R(B(a, x, b), y, B(c, z, d))
		| restore (R(a, x, R(b, y, c)), z, d) = R(B(a, x, b), y, B(c, z, d))
		| restore (a, x, R(R(b, y, c), z, d)) = R(B(a, x, b), y, B(c, z, d))
		| restore (a, x, R(b, y, R(c, z, d))) = R(B(a, x, b), y, B(c, z, d))
		| restore (a, x, b) = B(a, x, b)
		withtype {cl:color, cr:color, bh:nat, vl:nat, vr:nat | vl+vr <= 1}
		’a rbtree(cl, bh, vl) * ’a * ’a rbtree(cr, bh, vr) ->
		[c:color] ’a rbtree(c, bh+1, 0)
		exception ItemAlreadyExists
		fun insert cmp (x, t) = let
		fun ins (E) = R(E, x, E)
		| ins (B (a, y, b)) = (
		case cmp (x, y) of
		LESS => restore (ins a, y, b)
		| GREATER => restore(a, y, ins b)
		| EQUAL => raise ItemAlreadyExists
		)
		| ins (R (a, y, b)) = (
		case cmp (x, y) of
		LESS => R (ins a, y, b)
		| GREATER => R(a, y, ins b)
		| EQUAL => raise ItemAlreadyExists
		)
		withtype {c:color, bh:nat}
		’a rbtree(c, bh, 0) -> [c’:color, v:nat | v <= c] ’a rbtree(c’, bh, v)
		in case ins t of R(a, y, b) => B(a, y, b) | t => t end
		withtype {c:color, bh:nat} (’a * ’a -> ORDER) ->
		key * ’a rbtree(c, bh, 0) -> [bh’:nat] ’a rbtree(0, bh’, 0)

		Fig. 30. A red-black tree implementation

	A sort color is declared for the type index terms representing the colors of nodes.
	
	We use 0 for black and 1 for red.

	The type constructor rbtree is indexed with a triple (c, bh, v), where c, bh, v stand for the color of the node, the black height of the tree rooted at the node, and the number of color violations in the tree, respectively.

	We record one color violation if a red node is followed by another red one, and thus a valid RBT must have no color violations.

	Clearly, the types of value constructors associated with the type constructor rbtree indicate that color violations can only occur at the top node.

	Also, notice that a leaf, that is, E, is considered black.

	Given the datatype declaration and the explanation, it should be clear that the type of a RBT in which all keys are of type τ is simply:

		Σc:color.Σbh:nat. (τ )rbtree(c, bh, 0),

	that is, a RBT is a tree that has some top node color c and some black height bh but no color violations.

	It is an involved task to implement RBT.

	The implementation we present in Figure 30 is largely adopted from one in (Okasaki, 1998), though there are some minor modifications. We explain how the insertion operation on a RBT is implemented.

	Clearly, the invariant we intend to capture is that inserting an entry into a RBT yields another RBT.

	In other words, we intend to declare that the insertion operation has the following type:

		∀α.(α ∗ α → Bool) → α ∗ (α)RBT → (α)RBT

	where Bool is the type for booleans and (α)RBT is defined to be:

		Σc:color.Σbh:nat. (α)rbtree(c, bh, 0)

	If we insert an entry into a RBT, some properties on RBT may be invalidated, and the invalidated properties can then be restored through some rotation operations.
	
	The function restore in Figure 30 is defined for this purpose.
	
	The type of restore, though long, is easy to understand.

	It states that this function takes a tree with at most one color violation, an entry and a RBT, and returns a RBT.

	The two trees in the argument must have the same black height bh for some natural number bh and the black height of the returned RBT is bh + 1.

	This information can be of great help for understanding the code. It is not trivial at all to verify the information manually, and we could imagine that almost everyone who did this would appreciate the availability of a type-checker to perform it automatically.

	There is a substantial difference between type-checking a matching clause sequence in DML and in ML.

	The operational semantics of ML requires that pattern matching be performed sequentially, that is, the chosen pattern matching clause is always the first one that matches a given value.

	For instance, in the definition of the function restore, if the last clause is chosen at run-time, then we know the argument of restore does not match any one of the clauses ahead of the last one.

	This must be taken into account when we type-check pattern matching in DML. One approach is to expand patterns into disjoint ones.

	For instance, the pattern (a, x, b) expands into 36 patterns (pattern1, x, pattern2), where pattern1 and pattern2 range over the following six patterns:
		
		R(B , , B ), R(B , , E), R(E, , B ), R(E, , E), B , E
	
	Unfortunately, such an expansion may lead to combinatorial explosion.

	An alternative is to require the programmer to indicate whether such an expansion is needed.

	Neither of these was available in the original implementation of DML, and the author had to take the inconvenience to expand patterns into disjoint ones when necessary.

	Recently, we have implemented the alternative mentioned above.

	For instance, the last clause in the definition of restore can be written as follows:

		| restore (a, x, b) == B(a, x, b)

	where the special symbol == indicates to the type-checker that the pattern involved here needs to be (automatically) expanded into ones that are disjoint from the the patterns in the previous clauses.

	For a thorough study on the issue of type-checking pattern matching clauses in DML, please refer to (Xi, 2003).
	
	The complete implementation of the insertion operation follows immediately.
	
	Notice that the type of the function ins indicates that ins may return a tree with one color violation if it is applied to a tree with a red top node.

	This violation can be eliminated by replacing the top node with a black one for every returned tree with a red top node.
	
	Moreover, we can use an extra index to capture the size information of a RBT.

	If we do so, we can then show that the insert function always returns a RBT of size n+1 when given a RBT of size n (note that an exception is raised if the entry to be inserted already exists in the tree).

	A complete implementation of red-black trees is available on-line (Xi, 2005), which includes deletion and join operations as well.

	Also, several examples that make use of dependent types in capturing invariants in other data structures (e.g., Braun trees, random-access lists, binomial heaps) can be found in (Xi, 1999).
	
	We point out that it is also possible to capture the invariants of being a RBT by using nested datatypes (Kahrs, 2001).

	This is a rather different approach as it, to a large extent, employs run-time checking (in the form of pattern matching) to ensure that a binary tree meets the criteria of being a red-black tree.

	The use of nested datatypes essentially guarantees the adequacy of such run-time checking.

	A more systematic study on making use of nested types in capturing program invariants can be found in (Hinze, 2001).

- 7.3 A type-preserving evaluator
	
	We now implement an evaluator for an object language based on the simply typed λ-calculus, capturing in the type system of DML that the evaluator is type-preserving at the object level.

	Apart form using integer expressions as type indexes in the previous examples, we employ algebraic terms as type indexes in this example.

	We use the following syntax to define a sort ty for representing simple types in the object language:
	
		datasort ty = Bool | Int | Arrow of (ty, ty)
	
	where we assume that Bool and Int represent two simple base types ˆbool and int ˆ , respectively, and Arrow represents (the overloaded) constructor → for forming simple
	function types. For instance, we use the term Arrow(Int, Arrow(Int,Bool)) to represent the simple type int ˆ → (intˆ → ˆbool) in the object language, where ˆbool and int ˆ are two simple base types and (the overloaded) → is a simple type constructor.

	We use a form of higher-order abstract syntax (h.o.a.s) (Church, 1940; Pfenning & Elliott, 1988; Pfenning, n.d.) to represent expressions in the object language.

	In Figure 31, we declare a type constructor EXP, which takes a type

		datatype EXP (ty) =
		EXPint (Int) of int
		| EXPbool (Bool) of bool
		| EXPadd (Int) of EXP (Int) * EXP (Int)
		| EXPsub (Int) of EXP (Int) * EXP(Int)
		| EXPmul(Int) of EXP (Int) * EXP (Int)
		| EXPdiv(Int) of EXP (Int) * EXP (Int)
		| EXPzero (Bool) of EXP (Int)
		| {a: ty} EXPif (a) of EXP (Bool) * EXP (a) * EXP (a)
		| {a1: ty, a2: ty} EXPlam (Arrow (a1, a2)) of (EXP (a1) -> EXP (a2))
		| {a1: ty, a2: ty} EXPapp (a2) of (EXP (Arrow (a1, a2)), EXP (a1))
		| {a1: ty, a2: ty} EXPlet (a2) of (EXP (a1), (EXP(a1) -> EXP(a2)))
		| {a: ty} EXPfix (a) of (EXP (a) -> EXP (a))
		Fig. 31. A datatype for higher-order abstract syntax

	index term I of sort ty to form a type EXP(I) for the values that represent closed expressions in the object language that can be assigned the type represented by I.

	For example, the function λx : int ˆ .x + x in the object language is represented as EXPlam(lam x. EXPadd(x, x)), which can be given the type EXP(Arrow(Int,Int)).

	The usual factorial function can be represented as follows (in the concrete syntax of DML),

		EXPfix (lam f =>
		EXPlam (lam x =>
		EXPif (EXPzero (x),
		EXPint(1),
		EXPmul (x, EXPapp (f, EXPsub (x, EXPint(1)))))))

	which can also be given the type EXP(Arrow(Int,Int)).

	We often refer to such a representation as a form of typeful representation since the type of an expression in the object language is now reflected in the type of the representation of the expression.

	We now implement a function evaluate in Figure 32.

	The function is an evaluator for the object language, taking (the representation of) an object expression and returning (the representation of) the value of the object expression. Notice that the function is assigned the type Πa:ty. EXP(a) → EXP(a), indicating that the function is type-preserving at the object level.

	Also, we point out that (extended) type-checking in DML guarantees that no pattern matching failure can occur in this example.
	
	Clearly, a natural question is whether we can also implement a type-preserving evaluator for an object language based on the second-order polymorphic λ-calculus or system F (Girard, 1972).

	In order to do so, we need to go beyond algebraic terms, employing λ-terms to encode polymorphic types in the object language.

	First we extend the definition of the sort ty as follows so that universally quantified types can also be represented:

		datasort ty = ... | All of (ty -> ty)
		fun evaluate (v as EXPint _) = v
		| evaluate (v as EXPbool _) = v
		| evaluate (EXPadd (e1, e2)) = let // no pattern matching failure
		val EXPint (i1) = evaluate e1 and EXPint (i2) = evaluate e2
		in EXPint (i1+i2) end
		(* the cases for EXPsub, EXPmul, EXPdiv are omitted *)
		| evaluate (EXPzero e) = let // no pattern matching failure
		val EXPint (n) = evaluate e
		in EXPbool (n=0) end
		| evaluate (EXPif (e0, e1, e2)) = let // no pattern matching failure
		val EXPbool (b) = evaluate e0
		in if b then evaluate e1 else evaluate e2 end
		| evaluate (EXPapp (e1, e2)) = let // no pattern matching failure
		val EXPlam (f) = evaluate e1
		in evaluate (f (evaluate e2)) end
		(* the case for EXPlet is omitted *)
		| evaluate (v as EXPlam _) = v
		| evaluate (e as EXPfix f) = evaluate (f e)
		withtype {a: ty} EXP (a) -> EXP (a)

		Fig. 32. An implementation of a type-preserving evaluation function in DML

	Given a term f of sort ty → ty, All(f) represents the type ∀α. τ if for each type τ0, f(t) represents the type τ [α 7→ τ0] as long as t represents the type τ0.

	For instance, All(λa.Arrow(a, Arrow(a,Int))) represents the type ∀α.α → α → int; the term All(λa.(All(λb.Arrow(a, Arrow(b, a))))) represents the type ∀α.∀β.α → β → α.

	With this strategy, we have no difficulty in implementing a type-preserving evaluator for an object language based on the second-order polymorphic language calculus.

	We have actually already done this in the programming language ATS (Xi, 2005).

	Note that the type indexes involved in this example are drawn from Lλ.

	It is also possible to implement a type-preserving evaluator through the use of first-order abstract syntax (f.o.a.s), and further details on this subject can be found in (Chen & Xi, 2003; Chen et al., 2005), where some interesting typeful program transformations (e.g., a call-by-value continuation-passing style (CPS) transformation (Meyer & Wand, 1985; Griffin, 1990)) are studied.

	In (Xi et al., 2003), a typeful implementation of simply typed λ-calculus based on guarded recursive (g.r.) datatypes is presented.

	There, a g.r. datatype constructor HOAS (of the kind type → type) is declared such that for each simply typed λ-expression of some simple type T, its representation can be assigned the type (T)HOAS, where T is the representation of T. More precisely, T can be defined as follows:

		b = b T1 → T2 = T1 → T2

	where each simple base type b is represented by a type b (in the implementation language).

	For instance, the type for the representation of the simply typed expression λx : int ˆ .x is (int ˆ → int ˆ )HOAS, where int ˆ is a simple base type.

	With this representation for simply typed λ-calculus, an evaluation function of the type ∀α.(α)HOAS → α can be implemented.

	A particular advantage of this implementation is that we can use native tagless values in the implementation language to directly represent values of object expressions.

	This can be of great use in a setting (e.g., meta-programming) where the object language needs to interact with the implementation language (Chen & Xi, 2005b). Given that DML is a conservative extension of ML, this is clearly something that cannot be achieved in DML.

	The very reason for this is that DML does not allow type equalities like τ1 .= τ2 (meaning both τ1 ≤ τ2 and τ2 ≤ τ1) to appear in index contexts φ.

	In ATS, this restriction is lifted, resulting in a much more expressive type system but also a (semantically) much more complicated constraint relation (on types and type indexes) (Xi, 2004).
