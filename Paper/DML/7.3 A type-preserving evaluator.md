- 7.3 A type-preserving evaluator
- 7.3 型温存評価
	
	We now implement an evaluator for an object language based on the simply typed λ-calculus, capturing in the type system of DML that the evaluator is type-preserving at the object level.
	Apart form using integer expressions as type indexes in the previous examples, we employ algebraic terms as type indexes in this example.

	我々は現在、評価器が入力し保存型のオブジェクト·レベルであることをDMLの型システムでは、撮影、単純に型指定されたλ計算に基づいてオブジェクト言語のための評価を実施します。
	前の例で型のインデックスとして整数式を使用して別にフォームは、我々はこの例では、タイプの索引などの代数の用語を採用します。

	----

	We use the following syntax to define a sort ty for representing simple types in the object language:
	我々は、オブジェクト言語で単純型を表現するための種TYを定義するには、次の構文を使用します:

		datasort ty = Bool | Int | Arrow of (ty, ty)
	
	where we assume that Bool and Int represent two simple base types ˆbool and int ˆ , respectively, and Arrow represents (the overloaded) constructor → for forming simple
	function types. For instance, we use the term Arrow(Int, Arrow(Int,Bool)) to represent the simple type int ˆ → (intˆ → ˆbool) in the object language, where ˆbool and int ˆ are two simple base types and (the overloaded) → is a simple type constructor.

	We use a form of higher-order abstract syntax (h.o.a.s) (Church, 1940; Pfenning & Elliott, 1988; Pfenning, n.d.) to represent expressions in the object language.

	In Figure 31, we declare a type constructor EXP, which takes a type index term I of sort ty to form a type EXP(I) for the values that represent closed expressions in the object language that can be assigned the type represented by I.


	我々は、ブールとINTがそれぞれ、2シンプルな基本型ブール値とint型を表し、矢印は、単純な形成のための（オーバーロード）コンストラクタ→を表していることを前提と場所
	関数型。例えば、我々は長期的な矢印を使用（INTは、アロー（INT、ブール値））boolとintは2シンプルな基本型であるオブジェクト言語で簡単な型int→（INT→bool）を、表現すると（過負荷に）→単純型コンストラクタがある。

	オブジェクト言語で式を表現するために我々は、より高次の抽象構文（のHoA）（プフェニング、ND;プフェニング＆エリオット、1988教会、1940年）の形式を使用します。

	図31に、我々は型を取る型コンストラクタのEXPを宣言種ティの索引語IはIで表さタイプを割り当てることができるオブジェクト言語で閉じた表現を表す値の型EXP（I）を形成する

		datatype EXP (ty) =
		  EXPint (Int) of int
		| EXPbool (Bool) of bool
		| EXPadd (Int) of EXP (Int) * EXP (Int)
		| EXPsub (Int) of EXP (Int) * EXP(Int)
		| EXPmul(Int) of EXP (Int) * EXP (Int)
		| EXPdiv(Int) of EXP (Int) * EXP (Int)
		| EXPzero (Bool) of EXP (Int)
		| {a: ty} EXPif (a) of EXP (Bool) * EXP (a) * EXP (a)
		| {a1: ty, a2: ty} EXPlam (Arrow (a1, a2)) of (EXP (a1) -> EXP (a2))
		| {a1: ty, a2: ty} EXPapp (a2) of (EXP (Arrow (a1, a2)), EXP (a1))
		| {a1: ty, a2: ty} EXPlet (a2) of (EXP (a1), (EXP(a1) -> EXP(a2)))
		| {a: ty} EXPfix (a) of (EXP (a) -> EXP (a))
	
	Fig. 31. A datatype for higher-order abstract syntax

	図 31. 高階抽象構文のデータ型

	For example, the function λx : int ˆ .x + x in the object language is represented as EXPlam(lam x. EXPadd(x, x)), which can be given the type EXP(Arrow(Int,Int)).

	The usual factorial function can be represented as follows (in the concrete syntax of DML), which can also be given the type EXP(Arrow(Int,Int)).


	たとえば、関数λxの：INT.X+ xの対象言語はEXPlamとして表現されます（。ラムのX EXPadd（X、X））、タイプEXP（矢印（整数、整数））を与えることができる。

	通常の階乗関数は、（DMLの具象構文で）次のように表すことができ、これはまたタイプのEXP（矢印（整数、整数））を与えることができます。

		EXPfix (lam f =>
		  EXPlam (lam x =>
		    EXPif (EXPzero (x),
		           EXPint(1),
		           EXPmul (x, EXPapp (f, EXPsub (x, EXPint(1)))))))


	We often refer to such a representation as a form of typeful representation since the type of an expression in the object language is now reflected in the type of the representation of the expression.

	対象言語での式の型は、現在の式の表現の種類に反映されているので我々はしばしば、タイプ付きの表現の一形態としてこのような表現を参照してください。

	----

	We now implement a function evaluate in Figure 32.

	The function is an evaluator for the object language, taking (the representation of) an object expression and returning (the representation of) the value of the object expression. Notice that the function is assigned the type Πa:ty. EXP(a) → EXP(a), indicating that the function is type-preserving at the object level.

	Also, we point out that (extended) type-checking in DML guarantees that no pattern matching failure can occur in this example.

	我々は現在、機能は図32に評価する実装します。

	この関数は服用オブジェクト言語、（の表現）オブジェクト式と返す（の表現）オブジェクト式の値のための評価者です。 TYを：関数は、タイプπAが割り当てられていることに注意してください。 EXP（a）は、EXP→（a）は、関数が入力し、保存するオブジェクトレベルであることを示す。

	また、我々は指摘すること（拡張）型チェック、パターンマッチングの失敗は、この例では発生しないことをDML保証に。

	----
	
	Clearly, a natural question is whether we can also implement a type-preserving evaluator for an object language based on the second-order polymorphic λ-calculus or system F (Girard, 1972).
	In order to do so, we need to go beyond algebraic terms, employing λ-terms to encode polymorphic types in the object language.
	First we extend the definition of the sort ty as follows so that universally quantified types can also be represented:

	明らかに、自然な質問は、我々はまた、二次多型λ計算やシステムF（ジラール、1972）に基づいてオブジェクト言語の種類温存評価を実施することができるかどうかです。
	そうするためには、対象言語で多様型をエンコードするためにλ-項を採用し、代数的項を超えて移動する必要があります。
	普遍的に定量化された型も表すことができるように、次のようにまず、種TYの定義を拡張します。

		datasort ty = ... | All of (ty -> ty)
		
		fun evaluate (v as EXPint _) = v
		  | evaluate (v as EXPbool _) = v
		  | evaluate (EXPadd (e1, e2)) = let // no pattern matching failure
		      val EXPint (i1) = evaluate e1 and EXPint (i2) = evaluate e2
		    in EXPint (i1+i2) end
		    
		    (* the cases for EXPsub, EXPmul, EXPdiv are omitted *)

		  | evaluate (EXPzero e) = let // no pattern matching failure
		      val EXPint (n) = evaluate e
		    in EXPbool (n=0) end
		  | evaluate (EXPif (e0, e1, e2)) = let // no pattern matching failure
		      val EXPbool (b) = evaluate e0
		    in if b then evaluate e1 else evaluate e2 end
		  | evaluate (EXPapp (e1, e2)) = let // no pattern matching failure
		      val EXPlam (f) = evaluate e1
		    in evaluate (f (evaluate e2)) end
		
		    (* the case for EXPlet is omitted *)
		
		  | evaluate (v as EXPlam _) = v
		  | evaluate (e as EXPfix f) = evaluate (f e)
		withtype {a: ty} EXP (a) -> EXP (a)

	Fig. 32. An implementation of a type-preserving evaluation function in DML

	図32. DMLでの型温存評価関数の実装

	Given a term f of sort ty → ty, All(f) represents the type ∀α. τ if for each type τ0, f(t) represents the type τ [α 7→ τ0] as long as t represents the type τ0.

	For instance, All(λa.Arrow(a, Arrow(a,Int))) represents the type ∀α.α → α → int; the term All(λa.(All(λb.Arrow(a, Arrow(b, a))))) represents the type ∀α.∀β.α → β → α.

	With this strategy, we have no difficulty in implementing a type-preserving evaluator for an object language based on the second-order polymorphic language calculus.

	We have actually already done this in the programming language ATS (Xi, 2005).

	Note that the type indexes involved in this example are drawn from Lλ.

	種TY]→[TYの項fを考えると、すべてが（F）型∀αを表します。 τ各タイプのτ0のための場合には、f（t）は型τを表し[7α→τ0]としてロングTがタイプτ0を表しよう。

	たとえば、すべてが（λa.Arrowは（、矢印（、Intが）））タイプを表す∀α.α→α→int型。長期すべて（λaは。（すべて（λb.Arrow（、矢印（B、A）））））タイプ∀α.∀β.α→β→αを表します。

	この戦略により、我々は、2次多型言語結石に基づいてオブジェクト言語の種類温存評価を実装する難しさがありません。

	我々は、実際にすでにプログラミング言語ATS（XI、2005）でこれを行っています。

	この例に関与型のインデックスがLλから引き出されていることに注意してください。

	----

	It is also possible to implement a type-preserving evaluator through the use of first-order abstract syntax (f.o.a.s), and further details on this subject can be found in (Chen & Xi, 2003; Chen et al., 2005), where some interesting typeful program transformations (e.g., a call-by-value continuation-passing style (CPS) transformation (Meyer & Wand, 1985; Griffin, 1990)) are studied.

	それはで見つけることができる一次の抽象構文（foas）、そしてこの主題についての詳細を使用することによってタイプ温存評価を実施することも可能である（チェン·西、2003; Chenら、2005。）、ここで、いくつかの興味深いタイプ付きプログラムの変換（例えば、コール·バイ·価値継続渡しスタイル（CPS）変態（マイヤー＆杖、1985;グリフィン、1990））が検討されています。

	----

	In (Xi et al., 2003), a typeful implementation of simply typed λ-calculus based on guarded recursive (g.r.) datatypes is presented.

	There, a g.r. datatype constructor HOAS (of the kind type → type) is declared such that for each simply typed λ-expression of some simple type T, its representation can be assigned the type (T)HOAS, where T is the representation of T. More precisely, T can be defined as follows:

	で（XIら、2003）、保護された再帰的な（GR）のデータ型に基づいて、単純に入力されたλ計算のタイプ付きの実装が提供されます。

	そこでは、G。R.いくつかの単純な型Tの各単純に型指定されたλ-発現、その表現はTがより正確にTの表現であるタイプ（T）のHoAを割り当てることができること（種別型→タイプの）データ型コンストラクタのHoAは、宣言されている次のように、Tを定義することができます：

		b = b T1 → T2 = T1 → T2

	where each simple base type b is represented by a type b (in the implementation language).

	For instance, the type for the representation of the simply typed expression λx : int ˆ .x is (int ˆ → int ˆ )HOAS, where int ˆ is a simple base type.

	With this representation for simply typed λ-calculus, an evaluation function of the type ∀α.(α)HOAS → α can be implemented.

	A particular advantage of this implementation is that we can use native tagless values in the implementation language to directly represent values of object expressions.

	This can be of great use in a setting (e.g., meta-programming) where the object language needs to interact with the implementation language (Chen & Xi, 2005b). Given that DML is a conservative extension of ML, this is clearly something that cannot be achieved in DML.

	The very reason for this is that DML does not allow type equalities like τ1 .= τ2 (meaning both τ1 ≤ τ2 and τ2 ≤ τ1) to appear in index contexts φ.

	In ATS, this restriction is lifted, resulting in a much more expressive type system but also a (semantically) much more complicated constraint relation (on types and type indexes) (Xi, 2004).

	各単純な基本型bは、（実装言語）タイプbによって表されます。

	例えば、単純に型指定された表現λxのを表現するための型：int.Xです（INT→INT）intは、単純な基本型であるのHoA、。

	単に入力されたλ計算、型∀αの評価関数については、この表現と。（α）のHoAαを実現することができる→。

	この実装の特定の利点は、我々は、直接オブジェクト式の値を表現するために、実装言語のネイティブタグの付いていない値を使用することができることです。

	これは、オブジェクト言語が実装言語と対話する必要がある設定に大きな使用（例えば、メタプログラミング）であることができる（チェン·西、2005年b）。 DMLは、MLの保守的な拡張であることを考えると、これは明らかに、DMLで達成することができないものです。

	このために非常に理由は、DMLはτ1のようなタイプの等式を許可しないということです。=τ2は（意味の両方τ1≤τ2とτ2≤τ1）インデックスコンテキストのφに表示されるように。

	ATSでは、この制限も（XI、2004）（種類とタイプの索引に関する）（意味的に）はるかに複雑制約関係をはるかに表現型システムで、その結果、持ち上げているが。
