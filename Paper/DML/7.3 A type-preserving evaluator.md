- 7.3 A type-preserving evaluator
- 7.3 型保存評価器
	
	We now implement an evaluator for an object language based on the simply typed λ-calculus, capturing in the type system of DML that the evaluator is type-preserving at the object level.
	Apart form using integer expressions as type indexes in the previous examples, we employ algebraic terms as type indexes in this example.

	我々は今、単純型付けλ計算に基づいて対象言語のための評価器を実装し、評価器が対象レベルで型保存型であるDMLの型システムに取り込みます。

	前の例で型のインデックスとして整数式を使用しましたが、我々はこの例では型インデックスなどの代数データ型を採用します。

	----

	We use the following syntax to define a sort ty for representing simple types in the object language:

	我々は、対象言語で単純型を表現するための種tyを定義するには、次の構文を使用します:

		datasort ty = Bool | Int | Arrow of (ty, ty)
	
	where we assume that Bool and Int represent two simple base types ˆbool and int ˆ , respectively, and Arrow represents (the overloaded) constructor → for forming simple function types.
	For instance, we use the term Arrow(Int, Arrow(Int,Bool)) to represent the simple type int ˆ → (intˆ → ˆbool) in the object language, where ˆbool and int ˆ are two simple base types and (the overloaded) → is a simple type constructor.

	We use a form of higher-order abstract syntax (h.o.a.s) (Church, 1940; Pfenning & Elliott, 1988; Pfenning, n.d.) to represent expressions in the object language.

	In Figure 31, we declare a type constructor EXP, which takes a type index term I of sort ty to form a type EXP(I) for the values that represent closed expressions in the object language that can be assigned the type represented by I.


	ここで、BoolとIntがそれぞれ、2つの単純基本型 boolとintを表し、Arrowは、形成のための（オーバーロード）コンストラクタ→単純関数型を表していることを我々は前提としている。

	例えば、我々は、オブジェクト言語で簡単なint型→（int型→ブール値）を表現するために項Arrow(Int,Arrow(Int,Bool))を使用し、boolとintは2単純な基本型であり、（オーバーロード）→は単純な型コンストラクタです。

	対象言語で式を表現するために我々は、高階抽象構文(h.o.a.s)(Church, 1940; Pfenning & Elliott, 1988; Pfenning, n.d.)の形式を使用します。

	図31で、我々は型コンストラクタのEXPを宣言し、ここでEXPは種 tyの型インデックスの項Iを取り、対象言語で閉じた式を表す値の型EXP(I)を形成し、Iで表される型を割り当てることができます。

		datatype EXP (ty) =
		  EXPint (Int) of int
		| EXPbool (Bool) of bool
		| EXPadd (Int) of EXP (Int) * EXP (Int)
		| EXPsub (Int) of EXP (Int) * EXP(Int)
		| EXPmul(Int) of EXP (Int) * EXP (Int)
		| EXPdiv(Int) of EXP (Int) * EXP (Int)
		| EXPzero (Bool) of EXP (Int)
		| {a: ty} EXPif (a) of EXP (Bool) * EXP (a) * EXP (a)
		| {a1: ty, a2: ty} EXPlam (Arrow (a1, a2)) of (EXP (a1) -> EXP (a2))
		| {a1: ty, a2: ty} EXPapp (a2) of (EXP (Arrow (a1, a2)), EXP (a1))
		| {a1: ty, a2: ty} EXPlet (a2) of (EXP (a1), (EXP(a1) -> EXP(a2)))
		| {a: ty} EXPfix (a) of (EXP (a) -> EXP (a))
	
	Fig. 31. A datatype for higher-order abstract syntax

	図 31. 高階抽象構文のデータ型

	For example, the function λx : int ˆ .x + x in the object language is represented as EXPlam(lam x. EXPadd(x, x)), which can be given the type EXP(Arrow(Int,Int)).

	The usual factorial function can be represented as follows (in the concrete syntax of DML), which can also be given the type EXP(Arrow(Int,Int)).


	たとえば、関数 `λx : int ˆ .x + x` の対象言語はEXPlam(lam x. EXPadd(x, x))として表現され、型 EXP(Arrow(Int,Int))を与えることができます。

	通常の階乗関数は、(DMLの具象構文で)次のように表すことができ、これはまた型EXP(Arrow(Int,Int))を与えることができます。

		EXPfix (lam f =>
		  EXPlam (lam x =>
		    EXPif (EXPzero (x),
		           EXPint(1),
		           EXPmul (x, EXPapp (f, EXPsub (x, EXPint(1)))))))


	We often refer to such a representation as a form of typeful representation since the type of an expression in the object language is now reflected in the type of the representation of the expression.

	対象言語での式の型は、現在の式の表現の種類に反映されているので我々はしばしば、型付きの表現の一形態としてこのような表現を引用します。

	----

	We now implement a function evaluate in Figure 32.

	The function is an evaluator for the object language, taking (the representation of) an object expression and returning (the representation of) the value of the object expression.
	Notice that the function is assigned the type Πa:ty. EXP(a) → EXP(a), indicating that the function is type-preserving at the object level.

	Also, we point out that (extended) type-checking in DML guarantees that no pattern matching failure can occur in this example.

	我々は現在、evaluate関数を図32で実装します。

	この関数は対象言語、対象式（の表現）を取りと対象式の値（の表現）を返すのための評価器です。
	関数は、関数は、型温存対象レベルを示す型 `Πa:ty. EXP(a) → EXP(a)` が割り当てられていることに注意してください。 
	また、パターンマッチングの失敗は、この例では起こらない事をDMLの（拡張）型チェックが保証する事を我々は指摘します。

	----
	
	Clearly, a natural question is whether we can also implement a type-preserving evaluator for an object language based on the second-order polymorphic λ-calculus or system F (Girard, 1972).
	In order to do so, we need to go beyond algebraic terms, employing λ-terms to encode polymorphic types in the object language.
	First we extend the definition of the sort ty as follows so that universally quantified types can also be represented:

	明らかに、我々はまた二階の多相型λ計算やシステムF (Girard, 1972) に基づいて対象言語の型保存評価器を実装することができるかどうかが気になる問題です。
	そうするためには、対象言語で多層型をエンコードするためにλ-項を採用し、代数的項を超えて動かす必要があります。
	次のようにまず、普遍的に定量化された型も表すことができるように、種tyの定義を拡張します。

		datasort ty = ... | All of (ty -> ty)
		
		fun evaluate (v as EXPint _) = v
		  | evaluate (v as EXPbool _) = v
		  | evaluate (EXPadd (e1, e2)) = let // no pattern matching failure
		      val EXPint (i1) = evaluate e1 and EXPint (i2) = evaluate e2
		    in EXPint (i1+i2) end
		    
		    (* the cases for EXPsub, EXPmul, EXPdiv are omitted *)

		  | evaluate (EXPzero e) = let // no pattern matching failure
		      val EXPint (n) = evaluate e
		    in EXPbool (n=0) end
		  | evaluate (EXPif (e0, e1, e2)) = let // no pattern matching failure
		      val EXPbool (b) = evaluate e0
		    in if b then evaluate e1 else evaluate e2 end
		  | evaluate (EXPapp (e1, e2)) = let // no pattern matching failure
		      val EXPlam (f) = evaluate e1
		    in evaluate (f (evaluate e2)) end
		
		    (* the case for EXPlet is omitted *)
		
		  | evaluate (v as EXPlam _) = v
		  | evaluate (e as EXPfix f) = evaluate (f e)
		withtype {a: ty} EXP (a) -> EXP (a)

	Fig. 32. An implementation of a type-preserving evaluation function in DML

	図32. DMLでの型保存評価関数の実装

	Given a term f of sort ty → ty, All(f) represents the type ∀α. τ if for each type τ0, f(t) represents the type τ [α |→ τ0] as long as t represents the type τ0.

	種 `ty → ty` の項 `f` が与えられたとき、各々の型 `τ0` で、 `t` が 型 `τ0` を表し `f(t)` が `[α |→ τ0]` として型 `τ` を表すなら、 `All(f)` は型 `∀α. τ` を表します。

	For instance, All(λa.Arrow(a, Arrow(a,Int))) represents the type ∀α.α → α → int; the term All(λa.(All(λb.Arrow(a, Arrow(b, a))))) represents the type ∀α.∀β.α → β → α.

	たとえば、`All(λa.Arrow(a, Arrow(a,Int)))` が∀α.α→α→int型を表し; 項 `All(λa.(All(λb.Arrow(a, Arrow(b, a)))))` が 型 `∀α.∀β.α→β→α` を表します。

	With this strategy, we have no difficulty in implementing a type-preserving evaluator for an object language based on the second-order polymorphic language calculus.

	この戦略により、我々は、二階多相型言語計算に基づいて対象言語の型温存評価器を実装するのは難しくありません。

	We have actually already done this in the programming language ATS (Xi, 2005).

	我々は、実際にすでにプログラミング言語ATS(Xi, 2005)でこれを行っています。

	Note that the type indexes involved in this example are drawn from Lλ.

	この例に関わる型インデックスがLλから引き出されていることに注意してください。

	----


	VVVVVVV
	
	It is also possible to implement a type-preserving evaluator through the use of first-order abstract syntax (f.o.a.s), and further details on this subject can be found in (Chen & Xi, 2003; Chen et al., 2005), where some interesting typeful program transformations (e.g., a call-by-value continuation-passing style (CPS) transformation (Meyer & Wand, 1985; Griffin, 1990)) are studied.

	それはで見つけることができる一階の抽象構文（foas）、そしてこの主題についての詳細を使用することによってタイプ保存評価を実施することも可能である（チェン·西、2003; Chenら、2005。）、ここで、いくつかの興味深いタイプ付きプログラムの変換（例えば、コール·バイ·価値継続渡しスタイル（CPS）変態（マイヤー＆杖、1985;グリフィン、1990））が検討されています。

	----

	In (Xi et al., 2003), a typeful implementation of simply typed λ-calculus based on guarded recursive (g.r.) datatypes is presented.

	There, a g.r. datatype constructor HOAS (of the kind type → type) is declared such that for each simply typed λ-expression of some simple type T, its representation can be assigned the type (T)HOAS, where T is the representation of T. More precisely, T can be defined as follows:

	(Xi et al., 2003)で、保護された再帰的な (g.r.) のデータ型に基づいて、単純に入力されたλ計算のタイプ付きの実装が提供されます。

	そこでは、g.r.いくつかの単純な型Tの各単純に型指定されたλ-計算、その表現はTがより正確にTの表現であるタイプ（T）のHoAを割り当てることができること（種別型→タイプの）データ型コンストラクタのHoAは、宣言されている次のように、Tを定義することができます：

		b = b T1 → T2 = T1 → T2

	where each simple base type b is represented by a type b (in the implementation language).

	For instance, the type for the representation of the simply typed expression λx : int ˆ .x is (int ˆ → int ˆ )HOAS, where int ˆ is a simple base type.

	With this representation for simply typed λ-calculus, an evaluation function of the type ∀α.(α)HOAS → α can be implemented.

	A particular advantage of this implementation is that we can use native tagless values in the implementation language to directly represent values of object expressions.

	This can be of great use in a setting (e.g., meta-programming) where the object language needs to interact with the implementation language (Chen & Xi, 2005b). Given that DML is a conservative extension of ML, this is clearly something that cannot be achieved in DML.

	The very reason for this is that DML does not allow type equalities like τ1 .= τ2 (meaning both τ1 ≤ τ2 and τ2 ≤ τ1) to appear in index contexts φ.

	In ATS, this restriction is lifted, resulting in a much more expressive type system but also a (semantically) much more complicated constraint relation (on types and type indexes) (Xi, 2004).

	各単純な基本型bは、（実装言語）タイプbによって表されます。

	例えば、単純に型指定された表現λxのを表現するための型：int.Xです (int → int)は、単純な基本型であるのHoA、。

	単に入力されたλ計算、型∀αの評価関数については、この表現と。（α）のHoAαを実現することができる→。

	この実装の特定の利点は、我々は、直接対象式の値を表現するために、実装言語のネイティブタグの付いていない値を使用することができることです。

	これは、対象言語が実装言語と対話する必要がある設定に大きな使用（例えば、メタプログラミング）であることができる（チェン·西、2005年b）。 DMLは、MLの保守的な拡張であることを考えると、これは明らかに、DMLで達成することができないものです。

	このために非常に理由は、DMLはτ1のようなタイプの等式を許可しないということです。=τ2は（意味の両方τ1≤τ2とτ2≤τ1）インデックスコンテキストのφに表示されるように。

	ATSでは、この制限も（XI、2004）（種類とタイプの索引に関する）（意味的に）はるかに複雑制約関係をはるかに表現型システムで、その結果、持ち上げているが。
