- 5.5 Implementing elaboration
- 5.5の実装推敲

	A typed programming language ATS is currently under development (Xi, 2005), and its type system supports the form of dependent types in λΠ,Σ pat .

	The elaboration process in ATS is implemented in a manner that follows the presented elaboration rules closely, providing concrete evidence in support of the practicality of these rules.

	We now mention some strategies adopted in this implementation to address nondeterminism in elaboration.

	型付けされたプログラミング言語ATSは (XI, 2005)、現在開発中であり、その型システムはλΠで依存型、Σパットの形式をサポートしています。

	ATSでの精緻化プロセスは、これらの規則の実用性を支持する具体的な証拠を提供し、密接に提示推敲規則に従う方法で実装されています。

	我々は現在、精緻で非決定性に対処するために、この実装で採用され、いくつかの戦略に言及。


	- The dynamic subtype rules in Figure 21 are applied according to the order in which they are listed.

	- 図21の動的なサブタイプのルールは、リストされた順序に従って適用される。


		In other words, if two or more dynamic subtype rules are applicable, then the one listed first is chosen. It is important to always choose (dy-sub-Π-r) and (dy-sub-Σ-l) over (dy-sub-Π-l) and (dy-sub-Σ-r), respectively.

		二つ以上の動的なサブタイプの規則が適用され言い換えれば、その後最初にリストつが選択される。それは、常に（DY-サブΠ-R）および（DY-サブΣ-L）オーバー（DY-サブΠ-L）と（DY-サブΣ-R）、それぞれを選択することが重要である。


	For instance, this is necessary when we prove `∅; ∅ |- τ ≤ τ` for τ = Πa:int. int(a) → int(a) and also for τ = Σa:int. int(a).

	我々は証明したとき、例えば、これは∅が必要である。 INT：τ=πAため `∅ |- τ` さ≤τ。 INT（A）→INT（a）ともτのために=ΣA：INT。整数は、（a）。

	- The following ”left” rules:
		— (elab-up-Σ-left) and (elab-dn-Σ-left)
		— (elab-up-prod-left) and (elab-dn-prod-left)
		are chosen whenever they are applicable.

	- 以下の「左」のルール：
		- （機能一覧アップΣ-左）と（機能一覧-DN-Σ-左）
		- （機能一覧アップPROD-左）と（機能一覧-DN-PROD左）

		それらが適用可能なときはいつでも選択される。

	- The rule (elab-up-app-2) is in general chosen over the rule (elab-up-app-1).

	- ルール（機能一覧アップAPP-2）はルール（機能一覧アップAPP-1）の上に選ばれた一般的である。

		However, we also provide some special syntax to allow the programmer to indicate that the rule (elab-up-app-1) is preferred in a particular case.

		For instance, the special syntax for doing this in ATS is {...}: we write e1 {...}(e2) to indicate that a type of the form τ1 → τ2 needs to be synthesized out of e1 and then e2 is to be checked against τ1.

		This kind of elaboration is mostly used in a case where the expression e1 is a higher-order function, saving the need for explicitly annotating the expression e2.

		しかし、我々はまた、プログラマがルール（機能一覧アップAPP-1）は特定の場合に好適であることを示すために、できるようにいくつかの特別な構文を提供する。

		例えば、ATSでこれを行うための特別な構文は、{...}である：我々はその後E2を必要とτ2フォームτ1→のタイプは、E1から合成されることを示すために、E1{...}（E2）を書いて、 τ1と照合されるべきである。

		精緻この種の大部分は、明示的に発現e2が注釈を付ける必要性を保存する、式e1が高次関数である場合に使用される。

	- We choose the rule (elab-dn-up), which turns analysis into synthesis, only when no other analysis elaboration rules are applicable.

	- 我々は他の分析推敲規則が適用されない場合にのみ、合成に分析を回す規則（機能一覧-DNアップ）、選択します。

		The general principle we follow is to prefer analysis over synthesis as the former often makes better use of type annotations and yields more accurate error message report.

		我々は従う一般的な原理は、前者は、多くの場合、型注釈と利回りより正確なエラー·メッセージ·レポートのより良い利用したように合成上の分析を好むことです。

	While the description of elaboration in terms of the rules in Figure 21, Figure 22 and Figure 23 is intuitively appealing, there is still a substantial gap between the description and its implementation.

	For instance, the elaboration rules are further refined in (Xi, 1998) to generate constraints when applied, and there are also various issues of reporting error messages as informative as possible.

	As these issues are mostly concerned with an actual implementation of elaboration, they are of relatively little theoretical significance and thus we plan to address them elsewhere in different contexts.

	図21、図22と図23のルールの観点から精緻化の記述が直感的に魅力的ですが、説明とその実装の間に実質的なギャップがまだある。

	例えば、精緻化ルールがさらに適用されたときに制約を生成する（西、1998）で精製し、可能な限り有益なエラーメッセージを報告する様々な問題も存在している。

	これらの問題は主に推敲の実際の実装に関係していると、それらは比較的少ない理論的な重要性のものであり、したがって、我々は、異なるコンテキストで別の場所でそれらに対処する予定。