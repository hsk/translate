- 4 λ Π,Σ pat : Extending λpat with dependent types

	In this section, we introduce both universal and existential dependent types into the type system of λpat, leading to the design of a programming language schema λΠ,Σ pat (L) that parameterizes over a given type index language L.

	このセクションでは、与えられたタイプのインデックス言語L.上のパラメータ化プログラミング言語スキーマλΠ、Σパット（L）の設計につながる、λpatの型システムに両方のユニバーサルとexistential(実存)依存型を導入

- 4.1 Syntax

	Let us fix a type index language L.

	我々はタイプインデックス言語Lを修正しましょう

	We now present λΠ,Σ pat = λΠ,Σ pat (L), which is an extension of λpat with universal and existential dependent types.

	我々はここで、本λΠ、universal(普遍的)でexistential(実存)的依存型とλpatの拡張であるΣパット=λΠ、Σパット（L）、。

	The syntax of λΠ,Σ pat is given in Figure 12, which extends the syntax in Figure 3.

	λΠ、Σパットの構文は、図3の構文を拡張し、図12に与えられている。

	For instance, we use . . . in the definition of types in λΠ,Σ pat for the following definition of types in λpat:


	たとえば、使用しております。 。 。 λΠ、λpat内の型の次の定義のためのΣパット内の型の定義で：

		1 | τ1 ∗ τ2 | τ1 → τ2
	
	We now use δ for base type families. We may write δ for δ(), which is just an unindexed type.

	我々は現在、基本型家族のためにδを使用しています。私達はちょうどインデックスのないタイプであるδのためのδ（）を、書き込むことができる。

	We do not specify here as to how new type families can actually be declared.

	我々は、新しいタイプの家族が実際に宣言することができますどのように、ここで指定しないでください。

	In our implementation, we do provide a means for the programmer to declare type families.

	我々の実装では、プログラマがタイプファミリを宣言するための手段を提供します。

	For instance, in Section 1, there is such a declaration in the example presented in Figure 1.

	例えば、第1節では、図1に示す例では、そのような宣言があります。

	----

	We use the names universal (dependent) types, existential (dependent) types, guarded types and asserting types for types of the forms Πa:s. τ , Σa:s. τ , P ⊃ τ and P ∧ τ , respectively.

	我々は、フォームπAの種類の名前のユニバーサル（依存）の種類、existential(実存)（依存）のタイプ、保護されたタイプと主張するタイプを使用します。■。 τ、ΣA：S。それぞれτ、P⊃τとP∧τ、。

	Note that the type constructor ∧ is asymmetric.

	型コンストラクタは∧非対称であることに注意してください。

	In addition, we use the names universal expressions, existential expressions, guarded expressions and asserting expressions for expressions of the forms Π+(v), Σ(e), ⊃+(v) and ∧(e), respectively.

	また、我々は形の表現のために名前をuniversal(普遍的)な表現、existential(実存)的表現、保護された式と主張する表現を使用Π+（V）、Σ（E）、⊃+（V）と∧（e）は、それぞれ。

	----

	In the following presentation, we may write ~I for a (possibly empty) sequence of index terms I1, . . . , In; P~ for a (possibly empty) sequence of index propositions P1, . . . , Pn; Πφ for a (possibly empty) sequence of quantifiers:

	以下の発表では、書くことが〜私、索引語I1の（空）の配列について。 。 。 、では、用のP〜インデックス命題P1の（空）のシーケンス、。 。 。 、Pnは、数量詞の（空）の配列についてΠφ：

		Πa1 : s1 . . . Πan : sn, ` δ(s1, . . . , sn) φ ` Ik : sk for 1 ≤ k ≤ n
		φ ` δ(I1, . . . , In) [type]
		(tp-base)
		φ ` 1 [type]
		(tp-unit)
		φ ` τ1 [type] φ ` τ2 [type]
		φ ` τ1 ∗ τ2 [type]
		(tp-prod)
		φ ` τ1 [type] φ ` τ2 [type]
		φ ` τ1 → τ2 [type]
		(tp-fun)
		φ ` P : bool φ ` τ [type]
		φ ` P ⊃ τ [type]
		(tp-⊃)
		φ, a : s ` τ [type]
		φ ` Πa:s. τ [type]
		(tp-Π)
		φ ` P : bool φ ` τ [type]
		φ ` P ∧ τ [type]
		(tp-∧)
		φ, a : s ` τ [type]
		φ ` Σa:s. τ [type]
		(tp-Σ)
		φ ` ∅ [ctx]
		(ctx-emp)
		φ ` Γ [ctx] φ ` τ [type] xf 6∈ dom(Γ)
		φ ` Γ, xf : τ [ctx]
		(ctx-ext)

		Fig. 13. The type and context formation rules in λΠ,Σ pat

	where the index context φ is a1 : s1, . . . , an : sn; P~ ⊃ τ for P1 ⊃ (. . .(Pn ⊃ τ ). . .) if P~ = P1, . . . , Pn.

	----

	Notice that a form of value restriction is imposed in λΠ,Σ pat : It is required that e be a value in order to form expressions Π+(e) and ⊃ +(e).

	This form of value restriction can in general greatly simplify the treatment of effectful features such as references (Wright, 1995), which are to be added into λΠ,Σ pat in Section 6.

	We actually need to slightly relax this form of value restriction in Section 6.3 by only requiring that e be a value-equivalent expression (instead of a value) when Π+(e) or ⊃+(e) is formed.

	Generally speaking, a value-equivalent expression, which is to be formally defined later, refers to an expression that is operationally equivalent to a value.

	----

	Intuitively, in order to turn a value of a guarded type P ⊃ τ into a value of type τ , we must establish the proposition P; if a value of an asserting type P ∧ τ is generated, then we can assume that the proposition P holds.

	For instance, the following type can be assigned to the usual division function on integers,

		Πa1 :int.Πa2 :int. (a2 6= 0) ⊃ (int(a1) ∗ int(a2) → int(a1/a2))

	where / stands for the integer division function in some type index language. The

		φ; P~ |= I1
		.
		= I
		0
		1 · · · φ; P~ |= In
		.
		= I
		0
		n
		φ;P~ |= δ(I1, . . . , In) ≤
		s
		tp δ(I
		0
		1, . . . , I
		0
		n)
		(st-sub-base)
		φ; P~ |= 1 ≤
		s
		tp 1
		(st-sub-unit)
		φ;P~ |= τ1 ≤
		s
		tp τ
		0
		1 φ; P~ |= τ2 ≤
		s
		tp τ
		0
		2
		φ; P~ |= τ1 ∗ τ2 ≤
		s
		tp τ
		0
		1 ∗ τ
		0
		2
		(st-sub-prod)
		φ;P~ |= τ
		0
		1 ≤
		s
		tp τ1 φ; P~ |= τ2 ≤
		s
		tp τ
		0
		2
		φ; P~ |= τ1 → τ2 ≤
		s
		tp τ
		0
		1 → τ
		0
		2
		(st-sub-fun)
		φ; P~ , P
		0
		|= P φ; P~ , P
		0
		|= τ ≤
		s
		tp τ
		0
		φ; P~ |= P ⊃ τ ≤
		s
		tp P
		0 ⊃ τ
		0
		(st-sub-⊃)
		φ, a : s; P~ |= τ ≤
		s
		tp τ
		0
		φ; P~ |= Πa:s. τ ≤
		s
		tp Πa:s. τ
		0
		(st-sub-Π)
		φ; P~ , P |= P
		0 φ; P~ , P |= τ ≤
		s
		tp τ
		0
		φ; P~ |= P ∧ τ ≤
		s
		tp P
		0 ∧ τ
		0
		(st-sub-∧)
		φ, a : s; P~ |= τ ≤
		s
		tp τ
		0
		φ; P~ |= Σa:s. τ ≤
		s
		tp Σa:s. τ
		0
		(st-sub-Σ)

	- Fig. 14. The static subtype rules in λ Π,Σ pat

		x ↓ τ ⇒ (∅; ∅; x : τ )
		(pat-var)
		hi ↓ 1 ⇒ (∅; ∅; ∅)
		(pat-unit)
		p1 ↓ τ1 ⇒ (φ1; P~1; Γ1) p2 ↓ τ2 ⇒ (φ2; P~2; Γ2)
		<p1, p2> ↓ τ1 ∗ τ2 ⇒ (φ1, φ2; P~1, P~2; Γ1, Γ2)
		(pat-prod)
		φ0; P~0 ` cc(τ ) : δ(I1, . . . , In) p ↓ τ ⇒ (φ; P~ ; Γ)
		cc(p) ↓ δ(I
		0
		1, . . . , I
		0
		n) ⇒ (φ0, φ; P~0, P~ , I1
		.= I
		0
		1, . . . , In
		.= I
		0
		n; Γ)
		(pat-const)

	- Fig. 15. The typing rules for patterns

	following type is a rather interesting one:

		Πa:bool. bool(a) → (a.= true) ∧ 1

	This type can be assigned to a function that checks at run-time whether a boolean expression holds.

	In the case where the boolean expression fails to hold, some form of exception is to be raised.

	Therefore, this function acts as a verifier for run-time assertions made in programs.

	----

	In practice, we also have a notion of subset sort.

	We use sˆ to range over subset

		φ; P~ ; Γ ` e : τ1 φ;P~ |= τ1 ≤
		s
		tp τ2
		φ;P~ ; Γ ` e : τ2
		(ty-sub)
		φ ` Γ [ctx] Γ(xf ) = τ
		φ; P~ ; Γ ` xf : τ
		(ty-var)
		φ0; P~0 ` c(τ ) : δ(
		~I0) φ ` Θ : φ0 φ; P~ |= P~0[Θ] φ; P~ ; Γ ` e : τ [Θ]
		φ; P~ ; Γ ` c(e) : δ(
		~I0[Θ])
		(ty-const)
		φ ` Γ [ctx]
		φ; P~ ; Γ ` hi : 1
		(ty-unit) φ; P~ ; Γ ` e1 : τ1 φ;P~ ; Γ ` e2 : τ2
		φ; P~ ; Γ ` <e1, e2> : τ1 ∗ τ2
		(ty-prod)
		φ; P~ ; Γ ` e : τ1 ∗ τ2
		φ; P~ ; Γ ` fst(e) : τ1
		(ty-fst) φ; P~ ; Γ ` e : τ1 ∗ τ2
		φ; P~ ; Γ ` snd(e) : τ2
		(ty-snd)
		p ↓ τ1 ⇒ (φ0; P~0, Γ0) φ, φ0; P~ ; P~0; Γ, Γ0 ` e : τ2
		φ;P~ ; Γ ` p ⇒ e : τ1 → τ2
		(ty-clause)
		φ; P~ ; Γ ` pk ⇒ ek : τ1 → τ2 for k = 1, . . . , n
		φ; P~ ; Γ ` (p1 ⇒ e1 | · · · | pn ⇒ en) : τ1 → τ2
		(ty-clause-seq)
		φ; P~ ; Γ ` e : τ1 φ;P~ ; Γ ` ms : τ1 → τ2
		φ; P~ ; Γ ` case e of ms : τ2
		(ty-case)
		φ;P~ ; Γ, x : τ1 ` e : τ2
		φ; P~ ; Γ ` lamx. e : τ1 → τ2
		(ty-lam)
		φ; P~ ; Γ ` e1 : τ1 → τ2 φ;P~ ; Γ ` e2 : τ1
		φ; P~ ; Γ ` e1(e2) : τ2
		(ty-app)
		φ; P~ ; Γ, f : τ ` e : τ
		φ; P~ ; Γ ` fix f. e : τ
		(ty-fix)
		φ; P~ ; Γ ` e1 : τ1 φ; P~ ; Γ, x : τ1 ` e2 : τ2
		φ; P~ ; Γ ` let x = e1 in e2 end : τ2
		(ty-let)

		Fig. 16. The typing rules for λΠ,Σ pat (1)

	sorts, which are formally defined as follows:

		subset sort sˆ ::= s | {a : sˆ | P}

	where the index variable a in {a : sˆ | P} binds the free occurrences of a in P.
	
	Note that subset sorts, which extend sorts, are just a form of syntactic sugar.

	Intuitively, the subset sort {a : sˆ | P} is for index terms I of subset sort sˆ that satisfy the proposition P[a 7→ I]. For instance, the subset sort nat is defined to be {a : int | a ≥ 0}.

	In general, we may write {a : s | P1, . . . , Pn} for the subset sort sˆn defined as follows:

		sˆ0 = s sˆk = {a : sˆk−1 | Pk}
		φ; P~ , P; Γ ` v : τ
		φ; P~ ; Γ `⊃+(v) : P ⊃ τ
		(ty-⊃-intro)
		φ; P~ ; Γ ` e : P ⊃ τ φ; P~ |= P
		φ; P~ ; Γ `⊃−(e) : τ
		(ty-⊃-elim)
		φ, a : s;P~ ; Γ ` v : τ
		φ; P~ ; Γ ` Π
		+(v) : Πa:s. τ
		(ty-Π-intro)
		φ; P~ ; Γ ` e : Πa:s. τ φ ` I : s
		φ; P~ ; Γ ` Π
		−(e) : τ [a 7→ I]
		(ty-Π-elim)
		φ; P~ ; Γ ` e : τ φ; P~ |= P
		φ; P~ ; Γ ` ∧(e) : P ∧ τ
		(ty-∧-intro)
		φ; P~ ; Γ ` e1 : P ∧ τ1 φ; P~ , P; Γ, x : τ1 ` e2 : τ2
		φ;P~ ; Γ ` let ∧ (x) = e1 in e2 end : τ2
		(ty-∧-elim)
		φ; P~ ; Γ ` e : τ [a 7→ I] φ ` I : s
		φ; P~ ; Γ ` Σ(e) : Σa:s. τ
		(ty-Σ-intro)
		φ; P~ ; Γ ` e1 : Σa:s. τ1 φ, a : s; P~ ; Γ, x : τ1 ` e2 : τ2
		φ; P~ ; Γ ` let Σ(x) = e1 in e2 end : τ2
		(ty-Σ-elim)

		Fig. 17. The typing rules for λΠ,Σ pat (2)

	where k = 1, . . . , n.

	----

	We use φ; P~ ` I : {a : s | P1, . . . , Pn} to mean that φ; P~ ` I : s is derivable and φ; P~ ` Pi [a 7→ I] hold for i = 1, . . . , n.

	Given a subset sort sˆ, we write Πa:sˆ. τ for Πa:s. τ if sˆ is s, or for Πa:sˆ1. P ⊃ τ if sˆ is {a : sˆ1 | P}. Similarly, we write Σa:s. ˆ τ
	for Σa:s. τ if sˆ is s, or for Σa:sˆ1. P ∧ τ if sˆ is {a : sˆ1 | P}. For instance, we write Πa1 :nat. int(a1) → Σa2 :nat. int(a2) for the following type:

		Πa1 :int .(a1 ≥ 0) ⊃ (int(a1) → Σa2 :int .(a2 ≥ 0) ∧ int(a2)),

	which is for functions that map natural numbers to natural numbers.

- 4.2 Static semantics

	We start with the rules for forming types and contexts, which are listed in Figure 13.

	We use the syntax ` δ(s1, . . . , sn) to indicate that we can construct a type δ(I1, . . . , In) when given type index terms I1, . . . , In of sorts s1, . . . , sn, respectively.

	----

	A judgment of the form φ ` τ [type] means that τ is a well-formed type under the index context φ, and a judgment of the form φ ` Γ [ctx] means that Γ is a well-formed (expression) context under φ.

	The domain dom(Γ) of a context Γ is defined to be the set of variables declared in Γ.

	We write φ; P~ |= P0 for a regular constraint relation in the fixed type index language L.

	----

	In λΠ,Σ pat , type equality, that is, equality between types, is defined in terms of the static subtype relation ≤s tp:

	We say that τ and τ0 are equal if both τ ≤s tp τ0 and τ0 ≤s tp τ hold.

	By overloading |=, we use φ; P~ |= τ ≤s tp τ0 for a static subtype judgment and present the rules for deriving such a judgment in Figure 14.

	Note that all of these rules are syntax-directed.
	
	----

	The static subtype relation ≤s tp is often too weak in practice.

	For instance, we may need to use a function of the type τ1 = Πa:int. int(a) → int(a) as a function of the type τ2 = (Σa :int. int(a)) → (Σa :int. int(a)), but it is clear that τ1 ≤s tp τ2 does not hold (as ≤s tp is syntax-directed).

	We are to introduce in Section 4.6 another subtype relation ≤d tp, which is much stronger than ≤s tp and is given the name dynamic subtype relation.

	----

	The following lemma, which is parallel to Lemma 3.1, essentially states that the rules in Figure 14 are closed under substitution.

	- Lemma 4.1

		1. If φ, φ0; P~ |= τ ≤s
			tp τ
			0
			is derivable and φ ` Θ : φ0 holds, then φ; P~ [Θ] |=
			τ [Θ] ≤s
			tp τ
			0
			[Θ] is also derivable.

		2. If φ; P~ , P~
			0 |= τ ≤s
			tp τ
			0
			is derivable and φ; P~ |= P~
			0 holds, then φ; P~ |= τ ≤s
			tp τ
			0
			is also derivable.

	- Proof

		(Sketch) (1) and (2) are proven by structural induction on the derivations of

			φ, φ0; P~ |= τ ≤s
			tp τ
			0 and φ; P~ , P~
			0 |= τ ≤s
			tp τ
			0

		, respectively.
		Lemma 3.1 is needed in the proof. □
	
	As can be expected, the static subtype relation is both reflexive and transitive.

	- Proposition 4.2 (Reflexitivity and Transitivity of ≤s tp)

		1. φ; P~ |= τ ≤s
			tp τ holds for each τ such that φ ` τ [type] is derivable.
		2. φ; P~ |= τ1 ≤s
			tp τ3 holds if φ; P~ |= τ1 ≤s
			tp τ2 and φ; P~ |= τ2 ≤s
			tp τ3 do.
	- Proof

		Straightforward. □

	We now present the typing rules for patterns in Figure 15 and then the typing rules for expressions in Figure 16 and Figure 17.

	----

	The typing judgments for patterns are of the form p ↓ τ ⇒ (φ; P~; Γ), and the rules for deriving such judgments are given in Figure 15.

	A judgment of the form p ↓ τ ⇒ (φ; P~ ; Γ) means that for any value v of the type τ , if v matches p, that is, match(v, p) ⇒ θ holds for some substitution θ, then there exists an index substitution Θ such that ∅ ` Θ : φ, ∅; ∅ |= P~ [Θ] and (∅; ∅; ∅) ` θ : Γ[Θ].

	This is captured precisely by Lemma 4.10. In the rule (pat-prod), it is required that φ1 and φ2 share no common index variables in their domains.

	In the rule (pat-const), we write φ0; P~0 ` cc(τ ) : δ(I1, . . . , In) to mean that cc is a constant constructor assigned (according to some signature for constants) the following c-type:

		Πφ0.P~
		0 ⊃ (τ ⇒ δ(I1, . . . , In))

	In other words, given a constant constructor cc, we can form a rule (pat-const) for this particular cc based on the c-type assigned to cc.

	----

	The typing rules given in Figure 16 are mostly expected.

	The rule (ty-clause) requires that τ2 contain only type index variables declared in φ.

	For universal dependent types, existential dependent types, guarded types, and assertion types, the typing rules are given in Figure 17.

	Note that we have omitted certain obvious side conditions that need to be attached to some of these rules.

	For instance, in the rule (ty-Π-intro), the type index variable a is assumed to have no free occurrences in either P~ or Γ.

	Also, in the rule (ty-Σ-elim), the type index variable a is assumed to have no free occurrences in either P~, Γ or τ2.

	We now briefly go over some of the typing rules in Figure 17.

	- If a value v can be assigned a type τ under an assumption P, then the typing rule (ty-⊃-intro) assigns ⊃+(v) the guarded type P ⊃ τ .
		Notice the presence of value restriction here.
	- Given an expression e of type P ⊃ τ , the typing rule (ty-⊃-elim) states that the expression ⊃−(e) can be formed if the proposition P holds.
		Intuitively, a guarded expression is useful only if the guard can be discharged.
	- If e can be assigned a type τ and P holds, then the typing rule (ty-∧-intro) assigns ∧(e) the asserting type P ∧ τ .

	- The elimination rule for the type constructor ∧ is (ty-∧-elim).
		Assume that e2 can be assigned a type τ2 under the assumption that P holds and x is of type τ1.
	- If e1 is given the asserting type P ∧ τ1, then the rule (ty-∧-elim) assigns the type τ2 to the expression let ∧ (x) = e1 in e2 end.
		Clearly, this rule resembles the treatment of existentially quantified packages (Mitchell & Plotkin, 1988).

	The following lemma is parallel to Lemma 2.1. We need to make use of the assumption that the constraint relation involved here is regular when proving the first two statements in this lemma.

	- Lemma 4.3 (Thinning)

		Assume D :: φ; P~ ; Γ ` e : τ .

		1. For every index variable a that is not declared in φ, we have a derivation D0 :: φ, a : s; P~ ; Γ ` e : τ such that height(D) = height(D0).
		2. For every P such that φ ` P : bool is derivable, we have a derivation D0 :: φ; P~, P; Γ ` e : τ such that height(D) = height(D0).
		3. For every variable xf that is not declared in Γ and τ0 such that φ ` τ0[type] is derivable, we have a derivation D0:: φ; P~ ; Γ, xf : τ0 ` e : τ such that height(D) = height(D0).

	- Proof

		Straightforward. □

	The following lemma indicates a close relation between the type of a closed value in λΠ,Σ pat and the form of the value, which is needed in the proof of Theorem 4.12, the Progress Theorem for λΠ,Σ pat .

	- Lemma 4.4 (Canonical Forms)

		Assume that ∅; ∅; ∅ ` v : τ is derivable.

		1. If τ = δ(~I) for some type family δ, then v is of the form cc(v0), where cc is a constant constructor assigned a c-type of the form Πφ.P~ ⊃ (τ0 ⇒ δ(~I0)).
		2. If τ = 1, then v is hi.
		3. If τ = τ1 ∗ τ2, then v is of the form <v1, v2>.
		4. If τ = τ1 → τ2, then v is of the form lamx. e.
		5. If τ = P ⊃ τ0, then v is of the form ⊃+(v0).
		6. If τ = Πa:s. τ0, then v is of the form Π+(v0).
		7. If τ = P ∧ τ0, then v is of the form ∧(v0).
		8. If τ = Σa:s. τ0, then v is of the form Σ(v0).

	- Proof

		By a thorough inspection of the typing rules in Figure 16 and Figure 17. □

	Clearly, the following rule is admissible in λΠ,Σ pat as it is equivalent to the rule (ty-var) followed by the rule (ty-sub):

		φ ` Γ [ctx] Γ(xf) = τ φ; P~ |= τ ≤s
		tp τ
		0
		φ; P~ ; Γ ` xf : τ
		0
		(ty-var’)

	In the following presentation, we retire the rule (ty-var) and simply replace it with the rule (ty-var’).

	The following technical lemma is needed for establishing Lemma 4.6.

	- Lemma 4.5

			Assume D :: φ; P~; Γ, xf : τ1 ` e : τ2. If φ; P~ |= τ
			0
			1 ≤s
			tp τ1, then there exists D0
			::
			φ; P~ ; Γ, xf : τ
			0
			1 ` e : τ2 such that height(D) = height(D0
			).

	- Proof

		(Sketch) By structural induction on the derivation D.

		We need to make use of the fact that the rule (ty-var) is replaced with the rule (ty-var’) in order to show height(D) = height(D0). □

	The following lemma is needed in the proof of Theorem 4.11, the Subject Reduction Theorem for λΠ,Σ pat .

	- Lemma 4.6

		Assume D :: φ; P~; Γ ` v : τ . Then there exists a derivation D0 :: φ; P~ ; Γ ` v : τ such that height(D0) ≤ height(D) and the last typing rule applied in D0 is not (ty-sub).

	- Proof

		(Sketch) The proof proceeds by structural induction on D.

		When handling the case where the last applied rule in D is (ty-lam), we make use of Lemma 4.5 and thus see the need for replacing (ty-var) with (ty-var’). □

	Note that the value v in Lemma 4.6 cannot be replaced with an arbitrary expression.

	For instance, if we replace v with an expression of the form Π−(e), then the lemma cannot be proven.

	----

	The following lemma plays a key role in the proof of Theorem 4.11, the Subject Reduction Theorem for λΠ,Σ pat .

	- Lemma 4.7 (Substitution)

		1. Assume that φ, φ0; P~ ; Γ ` e : τ is derivable. If φ ` Θ : φ0 holds, then φ; P~[Θ]; Γ[Θ] ` e : τ [Θ] is also derivable.
		2. Assume that φ; P~ , P~0; Γ ` e : τ is derivable. If φ; P~ |= P~0 holds, then φ; P~ ; Γ `e : τ is also derivable.
		3. Assume that φ; P~ ; Γ, Γ0 ` e : τ is derivable. If φ; P~; Γ ` θ : Γ0 holds, then φ; P~; Γ ` e[θ] : τ is also derivable.

	- Proof

		(Sketch) All (1), (2) and (3) are proven straightforwardly by structural induction on the derivations of the typing judgments φ, φ0; P~ ; Γ ` e : τ , and φ; P~ , P~0; Γ ` e : τ , and φ; P~; Γ, Γ0 ` e : τ , respectively. □

- 4.3 Dynamic semantics

	We now need to extend the definition of evaluation contexts (Definition 2.4) as follows.

	- Definition 4.8 (Evaluation Contexts)

			evaluation contexts E ::= . . . | ⊃+(E) | ⊃−(E) | Π+(E) | Π−(E) |
			∧(E) | let ∧(x) = E in e end |
			Σ(E) | let Σ(x) = E in e end

		We are also in need of extending the definition of redexes and their reducts (Defi-nition 2.5).

	- Definition 4.9

		In addition to the forms of redexes in Definition 2.5, we have the following new forms of redexes:

		- ⊃−(⊃+(v)) is a redex, and its reduct is v.
		- Π−(Π+(v)) is a redex, and its reduct is v.
		- let ∧(x) = ∧(v) in e end is a redex, and its reduct is e[x 7→ v].
		- let Σ(x) = Σ(v) in e end is a redex, and its reduct is e[x 7→ v].

	Note that Definition 2.7, where V-form, R-form, M-form, U-form and E-form are defined, can be readily carried over from λpat into λΠ,Σ pat .

	----

	The following lemma captures the meaning of the typing judgments for patterns; such judgments can be derived according to the rules in Figure 15.

	- Lemma 4.10

		Assume that ∅; ∅; ∅ ` v : τ is derivable.
		If p ↓ τ ⇒ (φ; P~ ; Γ) and match(v, p) ⇒ θ are also derivable, then there exists Θ satisfying ∅ ` Θ : φ such that both ∅; ∅ |= P~ [Θ] and (∅; ∅; ∅) ` θ : Γ[Θ] hold.

	- Proof

		(Sketch) By structural induction on the derivation of p ↓ τ ⇒ (φ; P~ ; Γ). □

	----

		fun zip (nil, nil) = nil
		| zip (cons (x, xs), cons (y, ys)) = (x, y) :: zip (xs, ys)

	Fig. 18. An example of exhaustive pattern matching

- 4.4 Type soundness

	In order to establish the type soundness for λΠ,Σ pat , we make the following assumption:

	For each constant function cf assigned c-type Πφ.P~ ⊃ (τ ⇒ δ(~I)), if ∅; ∅ |= P~ [Θ] holds for some substitution Θ satisfying ∅ ` Θ : φ and ∅; ∅; ∅ ` v : τ [Θ] is derivable and cf(v) is defined to be v0, then ∅; ∅; ∅ ` v0 : δ(~I[Θ]) is also derivable.

	In other words, we assume that each constant function meets its specification. That is, each constant function respects its c-type assignment.

	- Theorem 4.11 (Subject Reduction)

		Assume ∅; ∅; ∅ ` e1 : τ and e1 ,→ev e2. Then ∅; ∅; ∅ ` e2 : τ is also derivable.

	- Proof

		A completed proof of this theorem is given in Appendix B. □

	- Theorem 4.12 (Progress)

		Assume that ∅; ∅; ∅ ` e1 : τ is derivable. Then there are only four possibilities:

		- e1 is a value, or
		- e1 is in M-form, or
		- e1 is in U-form, or
		- e1 ,→ev e2 holds for some expression e2.

		In particular, this implies that e1 cannot be in E-form.

	- Proof

		(Sketch) The proof immediately follows from structural induction on the derivation of ∅; ∅; ∅ ` e1 : τ .

		Lemma 4.4 plays a key role in this proof. □

	By Theorem 4.11 and Theorem 4.12, we can readily claim that for a well-typed closed expression e in λΠ,Σ pat , either e evaluates to a value, or e evaluates to an expression in M-form, or e evaluates to an expression in U-form, or e evaluates forever.

	----

	When compared to λpat, it is interesting to see what progress we have made in λΠ,Σ pat .

	We may now assign a more accurate type to a constant functions cf to eliminate the occurrences of undefined cf(v) for certain values v.

	For instance, if the division function on integers is assigned the following c-type:

		Πa1 :int.Πa2 :int. (a2 6= 0) ⊃ (int(a1) ∗ int(a2) ⇒ int(a1/a2))

	then division by zero causes to a type error and thus can never occur at run-time.

	Similarly, we may now assign a more accurate type to a function to eliminate some occurrences of expressions of the form case v of ms that are not ev-redexes.

	For instance, when applied to two lists of unequal length, the function zip in Figure 18 evaluates to some expression of the form E[case v of ms] where case v of ms is not an ev-redex.

	If we annotate the definition of zip with the following type annotation, withtype {n:nat} ’a list (n) * ’b list (n) -> (’a * ’b) list (n) that is, we assign zip the following type (which requires the feature of parametric polymorphism that we are to introduce in Section 6):

		∀α1.∀α2.Πa:nat. (α1)list(a) ∗ (α2)list(a) → (α1 ∗ α2)list(a)

	then zip can no longer be applied to two lists of unequal length.

	In short, we can now use dependent types to eliminate various (but certainly not all) occurrences of expressions in M-form or U-form, which would not have been possible previously.

	----

	Now suppose that we have two lists xs and ys of unknown length, that is, they are of the type Σa:nat. (τ )list(a) for some type τ . In order to apply zip to xs and ys, we can insert a run-time check as follows:

		let
			val m = length (xs) and n = length (ys)
		in
			if m = n then zip (xs, ys) else raise UnequalLength
		end

	where the integer equality function = and the list length function length are assumed to be of the following types:

		= : Πa1 :int.Πa2 :int. int(a1) ∗ int(a2) → bool(a1.= a2)
		length : ∀α.Πa:nat. (α)list(a) → int(a)

	Of course, we also have the option to implement another zip function that can directly handle lists of unequal length, but this implementation is less efficient than
	the one given in Figure 18.

- 4.5 Type index erasure

	In general, there are two directions for extending a type system such as the one in ML:

	One is to extend it so that more programs can be admitted as type-correct, and the other is to extend it so that programs can be assigned more accurate types.

	In this paper, we are primarily interested in the latter as is shown below.

	----

	We can define a function | · | in Figure 19 that translates types, contexts and expressions in λΠ,Σ pat into types, contexts and expressions in λpat, respectively.

	In particular, for each type family δ in λΠ,Σ pat , we assume that there is a corresponding type δ in λpat, and for each constant c of c-type Πφ.P~ ⊃ (τ ⇒ δ(~I)) in λΠ,Σ pat , we assume that c is assigned the c-type |τ | ⇒ δ in λpat.

	- Theorem 4.13

		Assume that φ; P~ ; Γ ` e : τ is derivable in λ Π,Σ pat .
		Then |Γ| ` |e| : |τ | is derivable in λpat.

	- Proof

		(Sketch) By structural induction on the derivation of φ; P~; Γ ` e : τ . □

			|δ(
			~I)| = δ
			|1| = 1
			|τ1 ∗ τ2| = |τ1| ∗ |τ2|
			|τ1 → τ2| = |τ1| → |τ2|
			|P ⊃ τ | = |τ |
			|Πa:s. τ | = |τ |
			|P ∧ τ | = |τ |
			|Σa:s. τ | = |τ |
			|∅| = ∅
			|Γ, xf : τ | = |Γ|, xf : |τ |
			|xf | = xf
			|c(e)| = c(|e|)
			|case e of (p1 ⇒ e1 | . . . | pn ⇒ en)| = case |e| of (p1 ⇒ |e1| | . . . | pn ⇒ |en|)
			|hi| = hi
			|<e1, e2>| = h|e1|, |e2|i
			|fst(e)| = fst(|e|)
			|snd(e)| = snd(|e|)
			|lam x. e| = lamx. |e|
			|e1(e2)| = |e1|(|e2|)
			|fix f. e| = fix f. |e|
			|⊃
			+(e)| = |e|
			|⊃
			−(e)| = |e|
			|Π
			+(e)| = |e|
			|Π
			−(e)| = |e|
			| ∧(e)| = |e|
			|let ∧(x) = e1 in e2 end| = let x = |e1| in |e2| end
			|Σ(e)| = |e|
			|let Σ(x) = e1 in e2 end| = let x = |e1| in |e2| end

			Fig. 19. The erasure function | · | on types, contexts and expressions in λΠ,Σ pat

	Given a closed expression e0 in λpat, we say that e0 is typable in λpat if ∅ ` e0 : τ0 is derivable for some type τ0; and we say that e0 is typable in λΠ,Σ pat if there exists an expression e in λΠ,Σ pat such that |e| = e0 and ∅; ∅; ∅ ` e : τ is derivable for some type τ .

	Then by Theorem 4.13, we know that if an expression e in λpat is typable in λΠ,Σ pat then it is already typable in λpat. In other words, λΠ,Σ pat does not make more expressions in λpat typable.

	- Theorem 4.14

		Assume that ∅; ∅; ∅ ` e : τ is derivable.

		1. If e ,→∗
			ev v in λ
			Π,Σ
			pat , then |e| ,→∗
			ev |v| in λpat.
		2. If |e| ,→∗
			ev v0 in λpat, then there is a value v such that e ,→∗
			ev v in λ
			Π,Σ
			pat and
			|v| = v0.

	- Proof

		(Sketch) It is straightforward to prove (1). As for (2), it follows from structural induction on the derivation of ∅; ∅; ∅ ` e : τ . □

	Theorem 4.14 indicates that we can evaluate a well-typed program in λΠ,Σ pat by first erasing all the markers Π+(·), Π−(·), ⊃+(·), ⊃−(·), Σ(·) and ∧(·) in the program and then evaluating the erasure in λpat.

	Combining Theorem 4.13 and Theorem 4.14, we say that λΠ,Σ pat is a conservative extension of λpat in terms of both static and dynamic semantics.

- 4.6 Dynamic subtype relation
	
	The dynamic subtype relation defined below is much stronger than the static subtype relation ≤s tp and it plays a key role in Section 5, where an elaboration process is presented to facilitate program construction in λΠ,Σ pat .

	- Definition 4.15 (Dynamic Subtype Relation)

		We write φ; P~ |= E : τ ≤d tp τ0 to mean that for any expression e and context Γ, if φ; P~ ; Γ ` e : τ is derivable then both φ; P~ ; Γ ` E[e] : τ0 is derivable and |e| ≤dyn |E[e]| holds.

		We may write φ; P~ |= τ ≤d tp τ0 if, for some E, φ; P~ |= E : τ ≤d tp τ0 holds, where E can be thought of as a witness to τ ≤d tp τ0.

		As is desired, the dynamic subtype relation ≤d tp is both reflexive and transitive.

	- Proposition 4.16 (Reflexitivity and Transitivity of ≤d tp)

		1. φ; P~ |= [] : τ ≤d tp τ holds for each τ such that φ ` τ [type] is derivable.
		2. φ; P~ |= E2[E1] : τ1 ≤d tp τ3 holds if φ; P~ |= E1 : τ1 ≤d tp τ2 and φ; P~ |= E2 : τ2 ≤d tp τ3 do, where E2[E1] is the evaluation context formed by replacing the hole [] in E2 with E1.

	- Proof

		(Sketch) The proposition follows from the fact that the relation ≤dyn is both re-flexive and transitive. □

- 4.7 A restricted form of dependent types
	
	Generally speaking, we use the name dependent types to refer to a form of types that correspond to formulas in some first-order many-sorted logic. For instance, the following type in λΠ,Σ pat :

		Πa:int. a ≥ 0 ⊃ (int(a) → int(a + a))

	corresponds to the following first-order formula:

		∀a : int.a ≥ 0 ⊃ (int(a) → int(a + a))

	where int is interpreted as some predicate on integers, and both ⊃ and → stand for the implication connective in logic. However, it is not possible in λΠ,Σ pat to form a dependent type of the form Πa : τ1. τ2, which on the other hand is allowed in a expressions

		e ::= x | c(e) | case e of (p1 ⇒ e1
		| . . . pn ⇒ en
		) |
		hi | he1
		, e2
		i | fst(e) | snd(e) |
		lamx. e | lamx : τ. e | e1
		(e2
		) |
		fix f : τ. e | let x = e1
		in e2
		end |
		λa : sˆ. e | e[I] | (e : τ )
		Fig. 20. The syntax for DML0

	(full) dependent type system such as λP (Barendregt, 1992).

	To see the difficulty in supporting practical programming with such types that may depend on programs, let us recall the following rule that is needed for determining the static subtype relation ≤s tp in λΠ,Σ pat :

		φ; P~ |= I
		.= I
		0
		φ; P~ |= δ(I) ≤s
		tp δ(I
		0
		)
		If I and I
		0 are programs, then I
		.= I
		0

	is an equality on programs.

	In general, if recursion is allowed in program construction, then it is not just undecidable to determine whether two programs are equal; it is simply intractable.

	In addition, such a design means that the type system of a programming language can be rather unstable as adding a new programming feature into the programming language may significantly affect the type system.

	For instance, if some form of effect (e.g., exceptions, references) is added, then equality on programs can at best become rather intricate to define and is in general impractical to reason about.

	Currently, there are various studies aiming at addressing these difficulties in order to support full dependent types in practical programming.

	For instance, a plausible design is to separate pure expressions from potentially effectful ones by employing monads and then require that only pure expressions be used to form types.

	As for deciding equalities on (pure) expressions, the programmer may be asked to provide proofs of these equalities. Please see (McBride, n.d.; Westbrook et al., 2005) for further details.

	----
	
	We emphasize that the issue of supporting the use of dependent types in practical programming is largely not shared by Martin-L¨of’s development of constructive type theory (Martin-L¨of, 1984; Martin-L¨of, 1985), where the principal objective is to give a constructive foundation of mathematics.

	In such a pure setting, it is perfectly reasonable to define type equality in terms of equality on programs (or more accurately, proofs).
