# ATSの論文



2.2 Dynamics

	ATS の dynamics は型付き言語で、種 type の静的な項は dynamics における型です。
	動的な定数をいくつか宣言することができ、引数 n の動的な定数 dc それぞれに次の形の dc 型を割り当てることができます。

		∀a1:σ1 ... ∀ak:σk　.　P1 ⊃ (... (Pm ⊃ ([s1,...,sn]=>tp s)) ...)

		⊃      : ガード型
		P      : 命題
		[]=>tp : 型コンストラクタ

		∀a1:σ1 ... ∀ak:σk　.　P1 ⊃
		(... (Pm ⊃ ([s1,...,sn]=>tp s)) ...)
		s~ : 静的な項の (空である可能性のある) 列

	このとき s1,...,sn,s は型であると仮定しています。

	dc が動的なコンストラクタ dcc である場合、なんらかの型コンストラクタ scc について 型 s は scc[s~] の形を取れなければなりません。

	すると dcc は scc と関連があると言えるのです。

	静的な項の (空である可能性のある) 列を表わすのに s~ を使っていることに注意してください。



	例えば、次のように dc 型を割り当てることで、2つの動的なコンストラクタ nil と cons を型コンストラクタ list と関連付けることができます。

		nil: ∀a: type.list[a,0]
		cons: ∀a: type.∀n:int.n ≥ 0 ⊃ ([a,list[a,n]] =>tp [a,n+1])

	このとき、要素の型が a で長さが n のリストを表わす型として list[a, n] を使っています。 動的な値を動的な項に写像する動的な置換を ΘD で表わします。


	ΘD : 動的な置換
	dom(ΘD) : ΘDのドメイン
	Θ1D ∪ Θ2D　: Θ1D と Θ2D の和集合 (dom(Θ1D) ∩ dom(Θ2D) = ∅ となるような Θ1D と Θ2D)
	• : 任意の構文
	∀Σ.• : Σ = a1:σ1,　...,　ak:σk において、∀a1:σ1 ...　∀ak:σk.•
	P⃗ ⊃ •　: P⃗ = P1,...,Pm において P1 ⊃ (...(Pm ⊃ •)...)
	dc 型 : 常に ∀Σ.P⃗ ⊃ ([s1, . . . , sn] ⇒tp s)

	また ΘD のドメインを dom(ΘD) で表わします。静的な置換と同じように、動的な置換を形成して適用するような構文を示すことを省きます。

	dom(Θ1D) ∩ dom(Θ2D) = ∅ となるような Θ1D と Θ2D が与えられたとき、Θ1D と Θ2D の和集合を Θ1D ∪ Θ2D で表わします。

	任意の構文を • で表わすと、Σ = a1:σ1,　...,　ak:σk において、∀a1:σ1 ...　∀ak:σk.• を ∀Σ.• と書くことができます。

	同様に、P⃗ = P1,...,Pm において P1 ⊃ (...(Pm ⊃ •)...) を P⃗ ⊃ • と書くことができます。

	例えば、dc 型は常に ∀Σ.P⃗ ⊃ ([s1, . . . , sn] ⇒tp s)の形になります。

	動的な定数の宣言を許可するために、シグニチャの定義を次のように拡張する必要があります。

		signatures S ::= ... | S,dc:∀Σ.P~ ⊃ ([s1,...,sn] =>tp s)
		元は
		signatures S ::= S0 | S,sc:[σ1,...,σn] => bでこれに追加される。


	さらに、シグニチャを作るために次のような追加のルールが必要になります。

		|- S [sig]    Σ|-S P:bool  for each P in P~
		Σ |-S si:type  for each 1 ≤ i ≤ n  Σ|-S s:type
		----------------------------------------------
		|- S,dc : ∀Σ.P~ ⊃ ([s1,...,sn] =>tp s) [sig]

	動的な項の変数として x を、動的な項として d を用いるとき、dynamics の構文を図 3 に示します。

	引数の個数が n の動的な定数 dc が与えられたとき、引数 d1,...,dn への dc の適用を dc[d1,...,dn] と書きます。

	n = 0 の場合には dc[] の代わりに dc と書くこともできます。


		dyn. terms     d ::= x | dc[d1,...,dn] | lam x.d | app(d1,d2) |
		                     ⊃+(v) | ⊃-(d) | ∧(d) | let ∧(x) = d1 in d2 |
		                     ∀+(v) | ∀-(d) | ∃(d) | let ∃(x) = d1 in d2
		values         v ::= x | dcc[v1,...,vn] | lam x.d | ⊃+(v) | ∧(d) | ∀+(v) | ∃(v)
		dyn. var. ctx. Δ ::= 0 | Δ, x:s
		dyn. subst.   ΘD ::= [] | ΘD[x |-> d]

	図 3 dynamics の構文

		|-S[sig]
		------------
		Σ|-S 0[dctx]

		Σ|-S Δ[dctx]     Σ|-S s:type
		----------------------------
		Σ|-S Δ,x:s[dctx]

	図 4 動的な可変コンテキストを表わす形成ルール

	型の導出において帰納的な意味付けに必要な Lemma 3 を証明するために、標識 ⊃+ (·), ⊃− (·), ∧(·), ∀+(·), ∀−(·), ∃(·) を導入します。
	これらの標識がないと、型の導出において帰納的証明を行なうことが、著しく困難になります。
	Lemma 3 を証明することも困難になってしまうでしょう。
	Σ ⊢S ∆[dctx] の形の判定は、Σ と S の下で ∆ が well-formed な動的な可変コンテキストであることを示しています。
	このような判定を導出するルールを図 4 に示します。
	型付けされたコンテキトを Σ; P⃗ ; ∆ で表わします。
	次のルールは ⊢S Σ;P⃗;∆の形の判定を導出しています。
	これは Σ; P⃗ ; ∆ が well-formed であることを示しています。


		Σ|-S P:bool  for each P in P~    Σ|-Δ[dctx]
		-------------------------------------------
		              |-S Σ;P~;Δ

	Σ; P⃗ ; ∆ が well-formed な型付けされたコンテキストで、かつ Σ ⊢S s : type 導出できると仮定したとき、型付け判定は
	Σ; P⃗ ; ∆ ⊢S d : s の形を取ります。

	制約関係 |=S が正則であると仮定したとき、このような判定を導くための型付けルール を図 5 に示します。

	Σ ⊢S ΘS : Σ0 と書くとき、それぞれの a ∈ dom(ΘS) = dom(Σ) について Σ ⊢S ΘS(a) : Σ(a) が導出できることを意味します。

	型付けルールに関連する明らかな条件のいくつかを省略していることに注意してください。

	例えば、ルール (ty-∀-intro) を適用するとき、P⃗, ∆ もしくは s において値 a は自由に出現 (free occurrences) できません。

	また値の形に、型付けルール (ty-gua-intro) と (ty-∀-intro) の制約を付けています。

	これは後で ATS に作用を導入するための準備です。

	*2 技術的な理由で、ルール (ty-var) を次のようなルールで置き換えます。

		|- S Σ;P~;Δ
		Δ(x)=s
		Σ;P~|=S s ≤tp s'
		---------------------------------------(ty-var')
		Σ;P~;Δ|-S x:s'

	これは (ty-var) と (ty-sub) を結合しています。
	この置換は Lemma 2 成立させるために必要です。


	図 5 dynamics の型付けルール

		Σ;P~;Δ|-S d:s
		Σ;P~|=S s ≤tp s'
		---------------------------------------(ty-sub)
		Σ;P~;Δ|-S d:s'


		|-S Σ;P~;Δ
		S(dc)=∀Σ0.P~0⊃[s1,...,sn]=>tp s
		Σ|-S ΘS:Σ0
		Σ;P~|=S P[ΘS] for each P ∈ P~0
		Σ;P~;Δ|-S di:si[ΘS] for i = 1,...,n
		Σ;P~|=S s[ΘS] ≤tp s'
		------------------------------------(ty-dc)
		Σ;P~;Δ|-S dc[d1,...,dn]:s'


		|-S Σ;P~;Δ
		Δ(x)=s
		Σ;P~|=S s ≤tp s'
		-----------------(ty-var)
		Σ;P~;Δ|-S x:s'

		Σ;P~;Δ,x:s1 |- d:s2
		---------------------------------------(ty-fun-intro)
		Σ;P~;Δ|-S lam x.d : s1 ->tp s2

		Σ;P~;Δ|S d1:s1->tp s2
		Σ;P~;Δ|-S d2:s1
		----------------------------------------(ty-fun-elim)
		Σ;P~;Δ|-S app(d1,d2):s2

		Σ;P~,P;Δ|-S d:s
		----------------------------------------(ty-gua-intro)
		Σ;P~;Δ|-S ⊃+(d):P ⊃ s

		Σ;P~;Δ|-S d:P⊃s
		Σ;P~|=S P
		----------------------------------------(ty-gua-elim)
		Σ;P~;Δ|-S ⊃-(d): s

		Σ;P~|=S P
		Σ;P~;Δ|-S d:s
		----------------------------------------(ty-ass-intro)
		Σ;P~;Δ|-S ∧(d):P ∧ s

		Σ;P~;Δ|-S d1:P∧s1
		Σ;P~,P;Δ,x:s1|-S d2:s2
		--------------------------------------------(ty-ass-elim)
		Σ;P~;Δ|-S let ∧(x)=d1 in d2:s2

		Σ,a:σ;P~;Δ|-S v:s
		----------------------------------------(ty-∀-intro)
		Σ;P~;Δ|-S ∀+(v):∀a:σ.s

		Σ;P~;Δ|-S d:∀a:σ.s
		Σ|-S s0;σ
		-------------------------------(ty-∀-elim)
		Σ;P~;Δ|-S ∀-(d):s[a|->s0]

		Σ|-S s0:σ
		Σ;P~;Δ|-S d:s[a|->s0]
		---------------------------------(ty-∃-intro)
		Σ;P~;Δ|-S ∃(d):∃a:σ.s

		Σ;P~;Δ|-S d1:∃a:σ.s1
		Σ,a:σ;P~;Δ,x:s1|-S d2:s2
		-----------------------------------------------(ty-∃-elim)
		Σ;P~;Δ|-S let ∃(x) = d1 in d2:s2

	ここで、動的な項を評価するルールの表現に進む前に、ガード型とアサート型がセキュリティを強制する役割を演じるような、興味深いシナリオをスケッチしてみましょう。

	これらの型を理解をさらに容易にしてくれるはずです。



	Example 2. Secret は命題定数で、password と action が次のような dc 型が割り当てられた 2 つの関数で宣言されている、 と仮定します。

		action: Secret ⊃ [1] =>tp 1
		password: [1] =>tp Secret ∧ 1

	password を呼び出しが返る前になんらかの secret 情報を検証しなければならない、というような方法で関数 password を 実装することができます。
	一方では、関数呼び出し action[⟨⟩] をする前に、命題 Secret を成立させなければなりません。
	このとき、⟨⟩ はユニット型 1 の値を意味します。
	もう一方、関数呼び出し password[⟨⟩] が返った後では、命題 Secret は 成立しています。
	従って、action 呼び出しは次のプログラムパターンを意味していることになります:

		let ∧(x) = password[⟨⟩]in ... action[⟨⟩] ...


	特に x のスコープ外における action 呼び出しは ill-typed です。
	なぜなら命題 Secret を成立させることができないからです。
	値渡し (call-by-value) の動的な構文を動的な項に割り当てるために、次に定義する評価コンテキストを利用します:

		eval. ctx. E ::= [] | dc[v1,...,vi-1,E,di+1,...,dn]|
		                 app(E,d) | app(v,E) | ⊃-(E) | ∀-(E) |
		                 ∧(E)|let ∧(x)=E in d | ∃(E) | let ∃(x) = E in d

	Definition 2.

		簡約基 (redex) と簡約 (reducation) を次のように定義します。

		• app(lam x.d, v) は簡約基で、その簡約は d[x |-> v] です。
		• ⊃− (⊃+ (v)) は簡約基で、その簡約は v です。
		• let ∧ (x) = ∧(v)ind は簡約基で、その簡約は d[x |-> v] です。
		• ∀−(∀+(v)) は簡約基で、その簡約は v です。
		• let∃(x) = ∃(v)ind は簡約基で、その簡約は d[x |-> v] です。
		• なんらかの値 v に等しく定義された dcf [v1 , . . . , vn ] は簡約基で、その簡約は v です。

		なんらかの簡約基 d とその簡約 d′ について d1 = E[d] かつ d2 = E[d′] のような 2 つの動的な項 d1 と d2 が与えられたとき、d1 |-> d2 は 1 ステップで d1 を d2 に簡約することを意味します。
		|-> の再帰的で推移的なクロージャを |->∗ で表わします。
		それぞれの動的な関数定数 dcf に割り当てられた型が妥当であると仮定します。
		すなわち、もし ∅; ∅; ∅ ⊢S dcf [v1 , . . . , vn ] : s が導出でき、かつ dcf[v1, . . . , vn] |-> v が成立するなら、∅; ∅; ∅ ⊢S v : s が導出できるとします。
		判定 J が与えられたとき、D が J の導出であることを示すために D :: J と書きます。
		つまり D が J を結論とする導出であることを意味しています。

	Lemma 1 (Substitution).

		次が成立します。
		(1) D::Σ,a:σ;P⃗;∆⊢S d:sとD0 ::Σ⊢S s0 :σを仮定します。
			するとΣ;P⃗[a|->s0];∆[a|->s0]⊢S d:s[a|->s0]を導出できます。
		(2) D :: Σ;P⃗,P;∆ ⊢S d : s と Σ;P⃗ |=S P を仮定します。
			すると Σ;P⃗;∆ ⊢S d : s を導出できます。
		(3) D::Σ;P⃗;∆,x:s1 ⊢S d2 :s2 とΣ;P⃗;∆⊢S d1 :s1 を仮定します。
			するとΣ;P⃗;∆⊢S d2[x|->d1]:s2 を導出できます。

	Proof.

		D に関する構造帰納法を使って (1),(2),(3) を簡単に証明できます。
		(1) と (2) を証明する際、規則ルール (reg-subst) と (reg-cut) をそれぞれ利用する必要があります。
		導出 D が与えられたとき、D の高さを h(D) で表わします。
		これは一般的な方法で定義できます。

	Lemma 2.

		D :: Σ;P⃗;∆,x : s1 ⊢S d : s2 と Σ;P⃗ |=S s′1 ≤tp s1 を仮定します。
		すると h(D′) = h(D) となるような導出 D′ :: Σ;P⃗;∆,x : s′1 ⊢S d : s2 が存在します。

	Proof.

		証明は D に対する構造帰納法を使ってすぐに得られます。D に最後に適用されたルールが (ty-var’) であるよう な場合を扱うために、規則ルール (reg-trans) を使います。
		ルール (tyrule-eq) が存在するために、次の反転は一般的なものと少し異なります。

	Lemma 3 (Inversion). D :: Σ; P⃗ ; ∆ ⊢S d : s を仮定します。

		(1) もしd=lamx.d1 かつs=s1 →tp s2 ならばh(D′)≤h(D)であるような導出D′ ::Σ;P⃗;∆⊢S d:sが存在します。
			なおかつ D′ に適用された最後のルールは (ty-sub) ではありません。
		(2) もしd=⊃+ (d1)かつs=P ⊃s1 ならばh(D′)≤h(D)であるような導出D′ ::Σ;P⃗;∆⊢S d:sが存在します。
			なおかつ D′ に適用された最後のルールは (ty-sub) ではありません。
		(3) もしd=∧(d1)かつs=P∧s1 ならばh(D′)≤h(D)であるような導出D′ ::Σ;P⃗;∆⊢S d:sが存在します。
			なおかつ D′ に適用された最後のルールは (ty-sub) ではありません。
		(4) もしd=∀+(d1)かつs=∀a:σ.s1 ならばh(D′)≤h(D)であるような導出D′ ::Σ;P⃗;∆⊢S d:sが存在します。
			なおかつ D′ に適用された最後のルールは (ty-sub) ではありません。
		(5) もしd=∃(d1)かつs=∃a:σ.s1 ならばh(D′)≤h(D)であるような導出D′ ::Σ;P⃗;∆⊢S d:sが存在します。
			なおかつ D′ に適用された最後のルールは (ty-sub) ではありません。

	Proof.

		h(D) に関する帰納法を使います。特に、(1) を成立するために Lemma 2 が必要になります。
		ATS の型の健全性は次に示す 2 つの定理に基づいています。これらの証明は一般的であるため、ここでは省略します。

	Theorem 1 (Subject Reduction).

		D :: Σ;P⃗;∆ ⊢S d : s と d |-> d′ の両方を仮定します。
		すると Σ;P⃗;∆ ⊢S d : s を導出できます。

	Theorem 2 (Progress).

		D :: ∅; ∅; ∅ ⊢S d : s を仮定します。
		すると、 d は値となるか、もしくはなんらかの動的な項 d′ に ついてd|->d′ が成立するか、
		もしくはなんらかの簡約基でない動的な項dcf(v1,...,vn)についてd=E[dcf(v1,...,vn)] が成立します。
