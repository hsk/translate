- 2 λpat: A starting point

	We introduce a simply typed programming language λpat, which essentially extends the simply typed λ-calculus with pattern matching.

	我々は基本的にパターンマッチングと単純に型付けされたλ計算を拡張し、単純に型付けされたプログラミング言語λpatを、紹介します。

	We emphasize that there are no new contributions in this section.

	我々は、このセクションに新たな貢献がないことを強調する。

	Instead, we primarily use λpat as an example to show how a type system is developed.

	その代わりに、我々は主に例としてλpat使用型システムが開発されているかを表示します。

	In particularly, we show how various properties of λpat are chained together in order to establish the type soundness of λpat. 

	特に、我々はλpatの様々な特性がλpatの型の健全性を確立するために、一緒に連鎖される方法を示しています。

	The subsequent development of the dependent type system in Section 4 and all of its extensions will be done in parallel to the development of λpat.

	4章とその拡張のすべての依存型システムのその後の開発はλpatの発展に並行して行われる。

	Except Lemma 2.14, all the results in this section are well-known and thus their proofs are　omitted.

	補題2.14を除いて、このセクションのすべての結果は、よく知られているので、それらの証明は省略します。

	----

	- Fig. 3. The syntax for λpat

			base types    δ ::= bool | int | . . .
			types         τ ::= δ | 1 | τ1 ∗ τ2 | τ1 → τ2
			patterns      p ::= x | f | hi | <p1, p2> | cc(p)
			matching clause seq. ms ::= (p1 ⇒ e1 | · · · | pn ⇒ en)
			constants     c ::= cc | cf
			expressions   e ::= xf | c(e) | hi | <e1, e2> | fst(e) | snd(e) | case e of ms |
			                    lam x. e | e1(e2) | fix f. e | let x = e1 in e2 end
			values        v ::= x | cc(v) | hi | <v1, v2> | lam x. e
			contexts      Γ ::= · | Γ, xf : τ
			substitutions θ ::= [] | θ[x 7→ v] | θ[f 7→ e]

	The syntax of λpat is given in Figure 3.

	λpatの構文は、図3に示されている。

	We use δ for base types such as int and bool and τ for types.

	我々はint型とブールの基本型用のδと型のτを使用しています。

	We use x for lam-bound variables and f for fix-bound variables, and xf for either x or f.

	我々は、xの為のlam-バインド変数とfにfix-バインドされた変数、およびxかfのいずれかのためにxfを使用しています。

	Given an expression e, we write FV(e) for the set of free variables xf in e, which is defined as usual.

	式eを考えると、我々はいつものように定義されているe内の自由変数の集合 xfをFV（e）と書く。

	----

	A lam-bound variable is considered a value but a fix-bound variable is not.

	lam-バインドされた変数は、値とみなされるがfix-バインド変数はありません。

	We use the name observable value for a closed value that does not contain a lambda expression lam x. e as its substructure.

	我々は、その基礎としてラムダ式のlam x. eが含まれていない、閉じた値の名前に観察可能な値を使用します。

	We use c for a constant, which is either a constant constructor cc or a constant function cf .

	我々は、定数コンストラクタccまたは定数関数cfのどちらかである定数、cを使用します。

	Each constant c is assigned a constant type (or c-type, for short) of the form τ ⇒ δ.

	各定数cは、τ⇒δの形の（略して、またはc型）定数型が割り当てられます。
	
	----

	Note that a c-type is not regarded as a (regular) type.

	c型は（レギュラー）型とはみなされないことに注意してください。

	For each constant constructor cc assigned the type 1 ⇒ δ, we may write cc as a shorthand for cc(<>), where <> stands for the unit of the unit type 1.

	型 1 ⇒ δ を割り当てられた各定数コンストラクタccのために、我々は、cc(<>)の省略形として、ccを書き、<>でユニット型1の単位を表します。

	In the following presentation, we assume that the boolean values true and false are assigned the type 1 ⇒ bool and every integer i is assigned the type 1 ⇒ int.

	以下の発表では、trueとfalseのbool値は、1⇒bool型が割り当てられ、すべての整数 i が1⇒int型を割り当てられていることを前提としています。

	Note that we do not treat the tuple constructor <·, ·> as a special case of constructors.

	我々は、コンストラクタの特殊なケースとして、タプルコンストラクタ<·, ·>を扱わないことに注意してください。

	Instead, we introduce tuples into λpat explicitly.

	その代わりに、我々は、明示的にλpatにタプルを導入する。

	The primary reason for this decision is that tuples are to be handled specially in Section 5, where an elaboration procedure is presented for supporting a form of partial type inference in the presence of dependent types.

	このように決めた主な理由は、5章で特別に扱われていますが、タプルの詳細な手順は依存型の存在下で部分的な型推論の形式をサポートするために提示されているためです。

	----


	We use θ for a substitution, which is a finite mapping that maps lam-bound variables x to values and fix-bound variables to fixed-point expressions.

	我々は、lam-bound変数xから値へ、fix-bound変数から固定小数点式へマッピングする有限の写像である置換のためθを使用します。

	We use [] for the empty substitution and θ[xf 7→ e] for the substitution that extends θ with a link from xf to e, where it is assumed that xf is not in the domain dom(θ) of θ.

	我々は、空の置換に[]を使用し、xfからeまでのリンクをθを拡張した置換のためにθ[xf 7 → e]使用し、ここでのxfはθのドメインのdom(θ)に登録されていないものとする。

	Also, we may write [xf1 |-> e1,..., xf n |-> en] for a substitution that maps xf i to ei for 1 ≤ i ≤ n.

	また、我々は1≤i≤nの範囲でxfiからeiへマップの置換を[xf1 |-> e1,..., xf n |-> en]と書くことができます。

	We omit the further details on substitution, which are completely standard.

	我々は完全に標準的な置換に関するさらなる詳細は、省略します。

	Given a piece of syntax • (representing expressions, evaluation contexts, etc.), we use •[θ] for the result of applying θ to •.

	構文•（式や評価コンテキスト等を表す）が与えられたとき、我々はθ を• に適用した結果のために•[θ]を使用する。

	----

	We use ∅ for the empty context and Γ, xf : τ for the context that extends Γ with one additional declaration xf : τ , where we assume that xf is not already declared in Γ.

	我々は、空のコンテキストに対して∅使用し、xfがすでにΓで宣言されていないと仮定して一つの追加の宣言xf : τでΓを拡張したコンテキストΓ, xf : τを使用します。


	A context `Γ = ∅, xf: τ1,...,xfn: τn` may also be treated as a finite mapping that maps xfi to τi for 1 ≤ i ≤ n, and we use dom(Γ) for the domain of Γ. 

	コンテキスト`Γ = ∅, xf: τ1,...,xfn: τn`はまた1 ≤ i ≤ nの範囲でxfi から τi への有限のマッピングとして処理することができ、そして我々はΓのドメインのdom(Γ)を使用します。

	Also, we may use Γ, Γ' for the context ∅, xf': τ1, ..., xfn : τn, xf'1 : τ'1,..., xf'n: τ'n , where Γ = ∅, xf 1: τ1,..., xfn : τn' and Γ' = ∅, xf'1: τ'1,..., xf'n: τ'n' and all variables xf1,...,xfn,xf'1,...,xf'n' are distinct.

	また、我々は、コンテキスト∅,xf': τ1, ..., xfn : τn, xf'1 : τ'1,..., xf'n: τ'nでΓ, Γ'を使用することができ、ここで Γ = ∅, xf 1: τ1,..., xfn : τn' で Γ' = ∅, xf'1: τ'1,..., xf'n: τ'n' で全ての変数 xf1,...,xfn,xf'1,...,xf'n' は異なります。

	----

	As a form of syntactic sugar, we may write let <x1, x2> = e1 in e2 end for the following expression:

	構文糖の形として、我々は次の式の事を let <x1, x2> = e1 in e2 end と書くことがあります:

		let x = e1 in let x1 = fst(x) in let x2 = snd(x) in e2 end end end

	where x is assumed to have no free occurrences in e1, e2.

	ここで、xは、e1とe2に自由変数として出現しないと仮定します。

- 2.1 Static semantics 静的意味論

	We use p for patterns and require that a variable occur at most once in a pattern.

	我々は、パターン列で、変数がパターン内に最大1回出現していることが必要なpを使用します。

	Given a pattern p and a type τ , we can derive a judgment of the form p ↓ τ ⇒ Γ with the rules in Figure 4, which reads that checking pattern p against type τ yields a context Γ.

	パターンpと型τを考えると、我々は、型τに対してパターンpをチェックするコンテキストΓが得られること読み込む図4のルールを持つ`p ↓ τ ⇒ Γ`の形の判断を導出することができます。

		------------- (pat-var)
		x ↓ τ ⇒ x : τ

		------------- (pat-unit)
		<> ↓ 1 ⇒ ∅

		p1 ↓ τ1 ⇒ Γ1   p2 ↓ τ2 ⇒ Γ2
		--------------------------- (pat-prod)
		<p1, p2> ↓ τ1 ∗ τ2 ⇒ Γ1, Γ2

		|- cc(τ):δ    p ↓ τ ⇒ Γ
		----------------------- (pat-const)
		cc(p) ↓ δ ⇒ Γ

		Fig. 4. The typing rules for patterns in λpat

		図.4. λpatにおけるパターンの型付け規則

	Note that the rule (pat-prod) is unproblematic since p1 and p2 cannot share variables.

	p1およびp2は、変数を共有することができないので、ルール(pat-prod)は問題がないことに注意してください。

	Also note that we write |- cc(τ) : δ in the rule (pat-const) to indicate that cc is a constant constructor of c-type τ ⇒ δ.

	また、我々はccはc-type τ ⇒ δの定数コンストラクタであることを示すために、ルール(pat-const) を|- cc(τ) : δ と書くことに注意してください

	As an example, let us assume that intlist is a base type, and nil and cons are constructors of c-types 1 ⇒ intlist and int ∗ intlist ⇒ intlist, respectively;

	例として、我々はintlistがベース型であり、nilとconsがそれぞれc-type 1 ⇒ intlistと int * intlist ⇒ intlist のコンストラクタであると仮定し;

	then the following judgments

	次の判決

		Γ(xf) = τ
		------------- (ty-var)
		Γ |- xf : τ

		|- c(τ ) : δ Γ |- e : τ
		--------------------- (ty-const)
		Γ |- c(e) : δ

		----------- (ty-unit)
		Γ |- hi : 1

		Γ |- e1 : τ1 Γ |- e2 : τ2
		----------------------- (ty-prod)
		Γ |- <e1, e2> : τ1 ∗ τ2

		Γ |- e : τ1 ∗ τ2
		--------------- (ty-fst)
		Γ |- fst(e) : τ1

		Γ |- e : τ1 ∗ τ2
		--------------- (ty-snd)
		Γ |- snd(e) : τ2

		p ↓ τ1 ⇒ Γ1 Γ, Γ1 |- e : τ2
		-------------------------- (ty-clause)
		Γ |- p ⇒ e : τ1 → τ2

		Γ |- pi ⇒ ei : τ1 → τ2 for i = 1, . . . , n
		------------------------------------------ (ty-clause-seq)
		Γ |- (p1 ⇒ e1 | · · · | pn ⇒ en) : τ1 → τ2

		Γ |- e : τ1 Γ |- ms : τ1 → τ2
		--------------------------- (ty-case)
		Γ |- case e of ms : τ2

		Γ, x : τ1 |- e : τ2
		--------------------- (ty-lam)
		Γ |- lamx. e : τ1 → τ2

		Γ |- e1 : τ1 → τ2 Γ |- e2 : τ1
		---------------------------- (ty-app)
		Γ |- e1(e2) : τ2

		Γ, f : τ |- e : τ
		---------------- (ty-fix)
		Γ |- fix f. e : τ

		Γ |- e1 : τ1 Γ, x : τ1 |- e2 : τ2
		------------------------------- (ty-let)
		Γ |- let x = e1 in e2 end : τ2

		Fig. 5. The typing rules for expressions in λpat

		図5.λpatにおける式の型付け規則


	are derivable:

	の導出は以下のとおりです:

		cons (hx, xsi) ↓ intlist ⇒ x : int, xs : intlist
		cons (hx, nil(hi)i) ↓ intlist ⇒ x : int

	----

	We present the typing rules for expressions in Figure 5.

	我々は、図5の式の型付け規則を提示する。

	The rule (ty-clause) is for assigning types to clauses.

	ルール(ty-clause)はclausesに型を割り当てます。

	Generally speaking, a clause p ⇒ e can be assigned the type τ1 → τ2 if e can be assigned the type τ2 under the assumption that p is given the type τ1.

	一般的に言えば、clause p ⇒ e はタイプτ1→τ2を割り当てることができます、ただしpに型τ1が与えられているという仮定の下でeに型τ2を割り当てることができる場合。

	----

	In the following presentation, given some form of judgment J, we use D :: J for a derivation of J.

	次のプレゼンテーションでは、判定Jの形が与えられた場合、我々は、Jの導出D:: Jを使用する。

	The structure of a derivation D is a tree, and we use height(D) for its height, which is defined as usual.

	導出Dは木構造であり、我々はその高さを通常通りに定義されたheight(D)を使用します。

	----

	The following standard lemma simply reflects that extra assumptions can be discarded in intuitionistic reasoning.

	次の標準補題は単に余分な仮定が直観的推論に廃棄され得ることを反映している。

	It is needed, for instance, in the proof of Lemma 2.3, the Substitution Lemma for λpat.

	それは、例えば、補題2.3の λpatの置換補題の証明で、必要とされる。

	- Lemma 2.1 (Thinning)

		Assume D :: Γ |- e : τ .
	
		D :: Γ |- e : τ と仮定する。

		Then there is a derivation D0:: Γ, xf : τ0 |- e : τ such that height(D) = height(D0), where τ0 is any well-formed type.

		次に、height(D) = height(D0)のような導出D0:: Γ, xf : τ0 |- e : τがある、ただしτ0は任意のwell-formedな型です。

		The following lemma indicates a close relation between the type of a closed value and the form of the value.

		次の補題は、閉じた値の型と値の形の間には密接な閉じた関係を示している。

		This lemma is needed to establish Theorem 2.9, the Progress Theorem for λpat.

		この補題はλpatのため定理2.9、進捗定理を確立するために必要とされる。

	- Lemma 2.2 (Canonical Forms)

		Assume that ∅ |- v : τ is derivable.

		∅ |- v : τが導出可能であると仮定する。

		1. If τ = δ for some base type δ, then v is of the form cc(v0), where cc is a constant constructor assigned a c-type of the form τ0 ⇒ δ.
		2. If τ = 1, then v is <>.
		3. If τ = τ1 ∗ τ2 for some types τ1 and τ2, then v is of the form <v1, v2>.
		4. If τ = τ1 → τ2 for some types τ1 and τ2, then v is of the form lam x. e.

		1. もしもδが基本型でτ = δならばvはcc(v0)でccはτ0⇒δの形のc-typeが割り当てられた定数コンストラクタです。
		2. もしも τ = 1 ならば v は <> です。
		3. もしも τ1 と τ2が型で τ = τ1 ∗ τ2 ならば v は <v1, v2>の型です。
		4. もしも τ1 と τ2が型で τ = τ1 → τ2 ならば v は lam x. eの型です。

		Note the need for c-types in the proof of Lemma 2.2 when the last case is handled.

		最後のケースが処理されるとき補題2.2の証明におけるc-typeが必要である事に注意してください。

		If c-types are not introduced, then a (primitive) constant function needs to be assigned a type of the form τ1 → τ2 for some τ1 and τ2.

		もしものc-typesが導入されない場合は、（プリミティブな）定数関数は、τ1とτ2が型のときのτ1→τ2の形の型を割り当てる必要がある。

		As a consequence, we can no longer claim that a value of the type τ1 → τ2 for some τ1 and τ2 must be of the form lam x. e as the value may also be a constant function. 

		結果として、我々はもはや値も定数関数とすることができるようにτ1とτ2が型のときの型τ1→τ2の値がlam x. eの形でなければならないと主張することができません。

		So the precise purpose of introducing c-types is to guarantee that only a value of the form lam x. e can be assigned a type of the form τ1 → τ2.

		だから、c-typesを導入する正確な目的は、lam x. e形の値のみがτ1→τ2の形の型を割り当てることができることを保証することです。

		----

		Given Γ, Γ0 and θ, we write Γ |- θ : Γ0 to indicate that Γ |- θ(xf) : Γ0(xf) is derivable for each xf in dom(θ) = dom(Γ0).

		Γ, Γ0 と Θ を考えると、我々はΓ：Γ0（xf）は各xfでdom(θ)= dom(Γ0) を誘導可能である事を示す為にΓ |-θ : Γ0 と書く。

		The following lemma is often given the name Substitution Lemma, which is needed in the proof of Theorem 2.8, the Subject Reduction Theorem for λpat.

		次の補題はしばしば、代入補題(Substitution Lemma)の名前が与えられ、これは定理2.8の証明、λpatための(Subject Reduction 定理)対象還元定理で必要とされる。

	- Lemma 2.3 (Substitution)

		Assume that Γ |- θ : Γ0 holds.

		Γ |- θ : Γ0があると仮定する。		

		If Γ, Γ0 |- e : τ is derivable, then Γ |- e[θ] : τ is also derivable.

		もしΓ, Γ0 |- e : τが導出されるならば、その後Γ |- e[θ] : τが導出出来る。

- 2.2 Dynamic semantics 動的意味論

	We assign dynamic semantics to expressions in λpat through the use of evaluation contexts defined as follows.

	我々は次のように定義された評価コンテキストを使用することによりλpatにおける式への動的な意味論を割り当てる。

	----

	- Definition 2.4 (Evaluation Contexts)
	- 定義2.4（評価コンテキスト）

			evaluation contexts E ::= [] | c(E) | <E, e> | <v, E> | fst(E) | snd(E) |
				case E of ms | E(e) | v(E) | let x = E in e end

		We use FV(E) for the set of free variables xf in E.

		我々は、Eにおける自由変数のxfの集合 FV(E)を使用します。

		Note that every evaluation context contains exactly one hole [] in it.

		すべての評価コンテキストが明らかに一つの空の[]が含まれていることに注意してください。

		Given an evaluation context E and an expression e, we use E[e] for the expression obtained from replacing the hole [] in E with e.

		評価コンテキストEと式eを考えると、我々はE中で空の[]とeの置換から得られた式のためにE[e]を使用する。

		As the hole [] in no evaluation context can appear in the scope of a lam-binder or a fix-binder, there is no issue of capturing free variables in such a replacement.

		無評価コンテキストの空の[]は、lam-binderまたはfix-binderのスコープに現れるているように、そのような置き換えに自由変数をキャプチャする問題はありません。

		----

			----------------------------------------(mat-var)
			match(v, x) ⇒ [x 7→ v]

			----------------------------------------(mat-unit)
			match(hi, hi) ⇒ []

			match(v1, p1) ⇒ θ1    match(v2, p2) ⇒ θ2
			----------------------------------------(mat-prod)
			match(<v1, v2>, <p1, p2>) ⇒ θ1 ∪ θ2

			match(v, p) ⇒ θ
			----------------------------------------(mat-const)
			match(c(v), c(p)) ⇒ θ

		Fig. 6. The pattern matching rules for λpat

		図6.λpat用パターンマッチングルール

		Given a pattern p and a value v, a judgment of the form match(v, p) ⇒ θ, which means that matching a value v against a pattern p yields a substitution for the variables in p, can be derived through the application of the rules in Figure 6.

		パターンpと値vが与えられると、match(v, p) ⇒ θの形の判断は、パターンpに対する値vに一致するページ内の変数の置換を生じることを意味し、図6のルールを適用して導き出すことができる。

		Note that the rule (mat-prod) is unproblematic because p1 and p2 can share no common variables as <p1, p2> is a pattern.

		ルール(mat-prod）はp1およびp2が<p1、p2>などの共通の変数を共有することはできないので、問題がないパターンであることに注意してください。

	- Definition 2.5
	- 定義2.5
	
		We define evaluation redexes (or ev-redex, for short) and their reducts in λpat as follows:

		次のように我々は、evalution redexes(評価簡約)（または短く書くとev-redex）とλpatでの還元を定義します。	

		- fst(<v1, v2>) is an ev-redex, and its reduct is v1.
		- fst(<v1, v2>)は評価簡約で還元はv1です。
		- snd(<v1, v2>) is an ev-redex, and its reduct is v2.
		- fst(<v1, v2>)は評価簡約で還元はv2です。
		- (lam x. e)(v) is an ev-redex, and its reduct is e[x → v].
		- (lam x. e)(v)は評価簡約で還元はe[x → v]です。
		- fix f. e is an ev-redex, and its reduct is e[f → fix f. e].
		- fix f. e は評価簡約で還元は e[f → fix f. e]です。
		- let x = v in e end is an ev-redex, and its reduct is e[x → v].
		- let x = v in e end は評価簡約で、還元はe[x → v]です。
		- case v of (p1 ⇒ e1 | · · · | pn ⇒ en) is an ev-redex if match(v, pk) ⇒ θ is derivable for some 1 ≤ k ≤ n, and its reduct is ek[θ].
		- case v of (p1 ⇒ e1 | · · · | pn ⇒ en) は 1 ≤ k ≤ nで match(v, pk) ⇒ θ が導出される場合の評価簡約で還元は ek[θ]です。
		- cf(v) is an ev-redex if (1) v is an observable value and (2) cf(v) is defined to be some value v0.

			In this case, the reduct of cf(v) is v0.
		- cf(v)はvが観察可能な値でかつcf(v)が値v0と定義するとき評価簡約です。

			この場合、cf(v)の還元(reduct)はv0である。

		Note that a value is observable if it does not contain any lambda expression lam x. e as its substructure.
		
		それは、その下部構造などの任意のラムダ式のlam x.e が含まれていない場合、値が観測可能であることに注意してください。

		値がその下部構造として、任意のラムダ式のlamxeが含まれていない場合に値が観察可能なであることに注意してください。

		The one-step evaluation relation ,→ev is defined as follows:

		ワンステップ評価関係→evが以下のように定義される:

		We write e1 ,→ev e2 if e1 = E[e] for some evaluation context E and ev-redex e, and e2 = E[e0], where e0 is a reduct of e.

		我々は評価コンテキストEと評価簡約 eのe1 = E[e]でe2=E[e0]でe0がeの還元の場合にe1, →ev e2と書く。


		We use ,→∗ ev for the reflexive and transitive closure of ,→ev and say that e1 ev-reduces (or evaluates) to e2 if e1 ,→∗ ev e2 holds.

		我々は、,→evの反射的推移的閉包のために,→* evを使用して`e1 ,→* ev e2`の場合にe1をe2にev-還元する（または評価する）と言う。

		There is certain amount of nondeterminism in the evaluation of expressions: case v of ms may reduce to e[θ] for any clause p ⇒ e in ms such that match(v, p) ⇒ θ is derivable.

		非決定性の一定量は、式の評価にあります：case v of ms は、ms内の任意の句p⇒eのe[θ]にそのようなmatch(v,p)⇒θが導出可能であると還元することができる。

		This form of nondeterminism can cause various complications, which we want to avoid in the first place.

		非決定性のこの形式は、我々が最初の箇所では避けたいさまざまな複雑化を引き起こす可能性があります。

		In this paper, we require that the patterns p1, ..., pn in a matching clause sequence (p1 ⇒ e1 | ··· | pn ⇒ en) be disjoint, that is, for 1 ≤ i |= j ≤ n, there are no values v that can match both pi and pj .

		本論文では、マッチング句シーケンスの(p1⇒e1 |···| pn⇒en)内でパターンp1,...,pnが互いに素である必要があり、つまり、1 ≤ i |= j ≤ n について、piとpjの両方を一致させることができない値vは存在しない。

		----

		In the actual implementation, we do allow overlapping patterns in a matching clause sequence, and we avoid nondeterminism by performing pattern matching in a deterministic sequential manner.

		実際の実装では、我々はマッチングのクロージャシーケンスでパターンの重複が可能で、決定論順次パターンマッチングを実行することによって、我々は非決定性を避ける。

		We could certainly do the same in the theoretical development, but this may complicate the evaluation of open programs, that is, programs containing free variables.

		我々は確かに理論的な発展に同じ事を行うことができますが、これは開いているプログラム(それはつまり、自由な変数を含むプログラム)の評価を複雑にする。

		For instance, let e1 and e2 be the following expressions case cons(x, xs) of (nil ⇒ true | x 0 ⇒ false) and case x of (nil ⇒
		true | x 0 ⇒ false), respectively.

		例えば、e1 と e2 はそれぞれ以下の式、case cons（x, xs）of (nil⇒true| x 0⇒false) と case x of (nil -> true | x 0 -> false)であるとする。

		Clearly, we should evaluate e1 to false, but we should not evaluate e2 to false as we do not know whether x matches nil or not.

		明らかに、我々はe1をfalseに評価する必要がありますが、我々は、xがnilかどう一致するかどうかわからないように、我々はe2をfalseに評価するべきではありません。

		This complication is simply avoided when patterns in a matching clause sequence are required to be disjoint.

		マッチングクロージャシーケンスのパターンが互いに素であることが要求されれば、この複雑化は、単純に回避される。

		----

		The meaning of a judgment of the form p ↓ τ ⇒ Γ is captured precisely by following lemma.
		
		p ↓ τ -> Γ の形式の判断の意味は、以下の補題で正確に捉えられる。

	- Lemma 2.6
	
		Assume that the typing judgment ∅ |- v : τ is derivable.

		型判断 ∅ |- v : τが導出可能と仮定する。

		If p ↓ τ ⇒ Γ and match(v, p) ⇒ θ are derivable, then ∅ |- θ : Γ holds.

		p ↓ τ ⇒ Γ と match(v, p) ⇒ θ が導出されるなら、∅ |- θ : Γである。

	- Definition 2.7
	- 定義2.7

		We introduce some forms to classify closed expressions in λpat.

		我々は、λpatで、閉じた式を分類するためにいくつかの形式を紹介する。

		Given a closed expression e in λpat, which may or may not be well-typed,

		λpat内で閉じているか、またはwell-typedではなくてもよい式eが与えられると、
	
		- e is in V-form if e is a value.
		- eはV-formにはいる、ただしeが値。
		- e is in R-form if e = E[e0] for some evaluation context E and ev-redex e0. So if e is in R-form, then it can be evaluated further.
		- eはR-formに入る、ただし評価コンテキストEと評価還元e0でe=E[e0]。もしeがR-formに入っているなら、これは将来評価される事が出来る。 
		- e is in M-form if e = E[case v of ms] such that case v of ms is not an ev-redex. This is a case where pattern matching fails because none of the involved patterns match v.
		- `case v of ms`がev-redexではないような`e = E[case v of ms]`の場合、eはM-formです。これは、関連パターンのどれもvと一致しないので、パターンマッチングが失敗した場合である。
		- e is in U-form if e = E[cf(v)] and cf(v) is undefined. For instance, division by zero is such a case.
		- `e= E[cf(v)]`でcf(v)が定義されていない場合、eはU-formである。例えば、ゼロで割ったようなケースです。
		- e is in E-form otherwise. We will prove that this is a case that can never occur during the evaluation of a well-typed program.
		- それ以外はeはE-formです。私たちは、これがwell-typedなプログラムの評価の中に現れることはできないケースであることを証明します。

		We introduce three symbols Error, Match and Undefined, and use EMU for the set {Error,Match, Undefined} and EMUV for the union of EMU and the set of observable values.

		我々は、3つのシンボル、エラー、マッチと未定義を導入し、EMU(集合{Error、Match、Undefined})とEMUV(EMUと観察可能な値の集合の和集合)を使用する。

		We write e ,→∗ ev Error, e ,→∗ ev Match and e ,→∗ ev Undefined if e ,→∗ ev e0 for some e0 in E-form, M-form and U-form, respectively.


		我々は`e ,→∗ ev e0`の  e0 が E-form, M-form か U-form ならば それぞれ`e ,→∗ ev Error`、 `e ,→∗ ev Match` または `e ,→∗ ev Undefined`と書く。

		----

		It can be readily checked that the evaluation of a (not necessarily well-typed) program in λpat may either continue forever or reach an expression in V-form, M-form, U-form, or E-form.

		それは容易にλpatで（必ずしもwell-typedではない）プログラムが永遠に続けるか、V型、M型、U型、またはE型での発現に到達することができるいずれかの評価をチェックすることができる。

		We will show that an expression in E-form can never be encountered if the evaluation starts with a well-typed program in λpat.

		我々は、評価がλpatではwell typedなプログラムで始まる場合は、E-formで式に遭遇することはできないことが分かります。

		This is precisely the type soundness of λpat.

		これが正確なλpatのタイプの健全性である。

- 2.3 Type soundness 型健全性

	We are now ready to state the subject reduction theorem for λpat, which implies that the evaluation of a well-typed expression in λpat does not alter the type of the expression.

	これでλpatでwell-typedな式の評価が式の型を変更しないことを意味しているλpatの対象還元定理(subject reduction theorem)を、明記する準備が整いました。

	----

	For each constant function cf of c-type τ ⇒ δ, if ∅ |- v : τ is derivable and c(v) is defined to be v0, then we require that ∅ |- v0 : δ be also derivable.

	c-type `τ ⇒ δ` の各定数関数cfで、もし`∅ |- v : τ`は導出可能で、`c(v)`が`v0`であると定義されている場合は、私たちは`∅ |- v0 : δ`が導出可能であることが必要である。

	In other words, we require that each constant function meet its specification, that is, the c-type assigned to it.

	言い換えれば、我々は各定数関数でその仕様を満たしている(すなわち、`c-type`が割り当てられる)ことを必要とする。

	- Theorem 2.8 (Subject Reduction)
	- 定理 2.8 (対称還元)

		Assume that ∅ |- e1 : τ is derivable and e1 ,→ev e2 holds.

		`∅ |- e1 : τ`を導出可能で、`e1,->ev e2`であると仮定します。

		Then `∅ |- e2 : τ` is also derivable.

		すると`∅ |- e2 : τ`も導出可能である。

		Lemma 2.3 is used in the proof of Theorem 2.8.

		補題2.3は定理2.8の証明に使用されている。

	- Theorem 2.9 (Progress)
	- 定理 2.9 (推移)

		Assume that `∅ |- e1 : τ` is derivable.

		`∅ |- e1 : τ`が導出出来ると仮定します。

		Then there are only four possibilities:

		すると、4つのうちいずれかの可能性がある:


		- e1 is a value, or
		- e1 is in M-form, or
		- e1 is in U-form, or
		- e1 ,→ev e2 holds for some expression e2.


		- e1 が値か
		- e1 がM-formか
		- e1 が U-formか
		- e1,→ev e2 がe2式を保持している

		Note that it is implied here that e1 cannot be in E-form.

		e1は、E-formであることができないことをここで暗黙的に示されていることに注意してください。

		Lemma 2.2 is needed in the proof of Theorem2.9.

		補題2.2はTheorem2.9の証明で必要とされる:

		----

		By Theorem 2.8 and Theorem 2.9, we can readily claim that for a well-typed closed expression e, either e evaluates to a value, or e evaluates to an expression in M-form, or e evaluates to an expression in U-form, or e evaluates forever.

		定理2.8と定理2.9により、我々はすぐにeが値に評価されるか、eがM-formな式と評価されるか、またはeがU-form な式に評価されるか、またはeは永遠に評価されることのいずれかをwell-typedな型付けされ閉じた式eに対して主張することができます。

		In particular, it is guaranteed that e ,→∗ ev Error can never happen for any well-typed expression e in λpat.

		特に、`e, →* ev` エラー が λpat内の任意のwell-typedな式eのために決して起こらないことが保証されている。
