- 3 Type index language

	We are to enrich λpat with a restricted form of dependent types.

	我々は、依存型の制限された形でλpatを強化を行う。

	The enrichment is to parameterize over a type index language from which type index terms are drawn.

	強化事項は、記述された型インデックス項から型インデックス言語上でパラメータ化することです。

		------------------------------------(reg-true)
		φ; P~ |= true
		
		------------------------------------(reg-false)
		φ; P~ , false |= P
		
		φ; P~ |= P0
		------------------------------------(reg-var-thin)
		φ, a : s; P~ |= P0
		
		φ |- P : bool φ; P~ |= P0
		------------------------------------(reg-prop-thin)
		φ; P~ , P |= P0
		
		φ, a : s; P~ |= P φ |- I : s
		------------------------------------(reg-subst)
		φ; P~ [a 7→ I] |= P[a 7→ I]
		
		φ; P~ |= P0 φ; P~ , P0 |= P1
		------------------------------------(reg-cut)
		φ; P~ |= P1
		
		φ |- I : s
		------------------------------------(reg-eq-refl)
		φ; P~ |= I .=s I
		
		φ;P~ |= I1 .=s I2
		------------------------------------(reg-eq-symm)
		φ;P~ |= I2 .=s I1

		φ; P~ |= I1 .=s I2 φ; P~ |= I2.=s I3
		------------------------------------(reg-eq-tran)
		φ; P~ |= I1 .=s I3

		Fig. 9. The regularity rules

	In this section, we show how a generic type index language L can be formed and then present some concrete examples of type index languages. 

	このセクションでは、ジェネリック型のインデックス言語Lが形成され、次いでタイプインデックス言語のいくつかの具体的な例を提示する方法を示しています。

	For generality, we will include both tuples and functions in L.

	一般性のために、我々は、Lの両方のタプルや機能が含まれます。

	However, we emphasize that a type index language can but does not necessarily have to support tuples or functions.

	しかし、我々はタイプインデックス言語は必ずしもタプルや機能をサポートする必要がないことを強調している。

	----

	The generic type index language L itself is typed.

	ジェネリック型のインデックス言語L自体が型付けされている。

	In order to avoid potential confusion, we call the types in L type index sorts (or sorts, for short).

	混乱を避けるために、我々は、Lタイプインデックスソート(略して、またはソート)内の型を呼び出す。

	fig 7.

		b: base sorts. bool or ...
		C: constant sort = c-sort = (s1, . . ., sn) -> b 

	We use a for index variables and C for constants, which are either constant functions or constant constructors.

	我々はインデックス変数か、Cの生成ための定数関数や定数コンストラクタを使用します。

	Each constant is assigned a constant sort (or c-sort, for short) of the form (s1, . . . , sn) ⇒ b, which means that C(I1, . . . , In) is an index term of sort b if Ii are of sorts si for i = 1, . . . , n.


	インスタンス

	For instance, true and false are assigned the c-sort () ⇒ bool. We may write C for C() if C is a constant of c-sort () ⇒ b for some base sort b.

	シグニチャS

	We assume that the c-sorts of constants are declared in some signature S associated with L, and for each sort s, there is a constant function .=s of the c-sort (s, s) ⇒ bool.

	.=

	We may use .= to mean .=s for some sort s if there is no risk of confusion.

	Fig 8.

	----

	We present the sorting rules for type index terms in Figure 8, which are mostly standard.

	我々は、ほとんどが標準的である図8のタイプインデックスの用語、のソートルールを提示する。

	We use P for index propositions, which are index terms that can be assigned the sort bool (under some index context φ), and P~ for a sequence of propositions, where the ordering of the terms in this sequence is of no significance.

	我々は、このシーケンスの条件の順序は重要ではない命題のシーケンスのために（いくつかの指標のコンテキストφ下）ソートBOOLを割り当てることができますインデックス用語であるインデックス命題、およびP〜のためにPを使用しています。

	----

	We may write φ |- P~ : bool to mean that φ |- P : bool is derivable for every P in P~.

	BOOLがP内のすべてのP〜のために誘導可能である：P - |それはφ意味するBOOL：P〜 - |我々は、φを書き込むことができる。

	In addition, we may use φ |- Θ : φ0 to indicate that φ |- Θ(a) : φ0(a) holds for each a in dom(Θ) = dom(φ0).

	また、我々はφを使用することがあります| - Θ：φ0はそれがφを示すために| - Θ（A）：φ0（a）の各AのDOM（Θ）= DOM（φ0）についても同様である。

- 3.1 Regular constraint relation 正規制約関係

	A constraint relation φ; P~ |= P0 is defined on triples φ, P~, P0 such that both φ |-
	P~ : bool and φ |- P0 : bool are derivable.

	制約関係（ φ ; P 〜 | = P0 ）は３つの（ φ 、 P 〜 、 P0）で定義されており、（ φ| - 
	P 〜：ブール値）と（ φ| - P0：ブール値）両方が導出可能である。

	We may also write φ; P~ |= P~0 to mean that　φ; P~ |= P0 holds for each P0 in P~0.

	我々はまた、（ φ ; P~ | = P~0 ）と書くことが（ φ ; P~ | = P0） ことを意味していて、P~0の各P0についても同様である。

	We say that a constraint relation φ; P~ |= P0 is regular if all the regularity rules in Figure 9 are valid, that is, the conclusion of a regularity rule holds whenever all the premises of the regularity rule do.

	図9のすべての規則性の規則が有効であるか|; （ = P0 P 〜 φ ）それは、規則性ルールの結論は規則性ルールのすべての施設が行うたびに保持され、規則的である我々は、制約関係があることを言う。

	我々は、図9のすべての規則性の規則が有効な場合、制約関係 φ; P~ |= P0 はつまり、規則性ルールの結論は規則性ルールのすべての施設が行うたびに保持され、定期的であると言う。

		----------------(reg-true)
		φ; P~ |= true

	命題の集まりPはtrueが導出出来る。

		----------------(reg-false)
		φ; P~,false |= P

	P~,falseは存在する。

		φ; P~ |= P0
		----------------(reg-var-thin)
		φ,a:s; P~ |= P0


	変数が加わっても同じ。


		φ|- P:bool      φ;P~ |= P0
		--------------------------(reg-prop-thin)
		φ,a:s; P~ |= P0

	Pが命題で、制約関係φでP~にP0の制約関係があるならば
	変数が加わっても制約関係φでP~にP0は変わらない。


		φ,a:s;P~ |= P        φ |- I:s
		-----------------------------(reg-subst)
		φ; P~[a |-> I ] |= P[a |-> I]

	型がsの変数aが環境内にあってP~ |= Pで φ 内に変数 I:sがあるとき

		φ; P~[a |-> I ] |= P[a |-> I]

	命題の集合のP~内のaがIならP内のaもIだ。 


		φ;P~ |= P0      φ;P~,P0 |- P1
		-----------------------------(reg-cut)
		φ; P~ |= P1

	φ;P~ |= P0かつφ;P~,P0 |- P1ならφ; P~ |= P1だ。


	Note that　the rules (reg-eq-refl), (reg-eq-symm) and (reg-eq-tran) indicate that for each　sort s, .=s needs to be interpreted as an equivalence relation on expressions of the　sort s.

	ルール（REG-EQ-REFL）、（REG-EQ-SYMM）と（REG-EQ-TRAN）は各ソート s、.= Sはソートsの式に同値関係として解釈される必要があることを示していることに注意してください。

		φ |- I:s
		----------------(reg-eq-refl)
		φ; P~ |= I .= I

	反射率

		φ;P~ |= I1 .= I2
		----------------(reg-eq-symm)
		φ;P~ |= I2 .= I1

	対称律

		φ;P~ |= I1 .= I2     φ;P~|= I2 .= I3
		------------------------------------(reg-eq-tran)
		φ; P~ |= I1 .= I3

	推移律

	３つまとめて、同値関係

	----

	Essentially, we want to treat a constraint relation as an abstract notion. 

	基本的に、我々は、抽象概念としての制約関係を扱いたい。

	However,　in order to use it, we need to specify certain properties it possesses, and this is　precisely the motivation for introducing regularity rules.

	しかし、それを使用するために、我々はそれが有する特定のプロパティを指定する必要があり、これは正確に規則性ルールを導入するための動機である。

	For instance, we need the regularity rules to prove the following lemma.

	たとえば、我々は次の補題を証明するために規則の規則を必要とする。


	- Lemma 3.1 (Substitution)

		- Assume φ, φ0; P~ |= P0
			and φ |- Θ : φ0.        Then φ; P~ [Θ] |= P0[Θ] holds.
		- Assume φ; P~ , P~0 |= P0
			and φ; P~       |= P~0. Then φ; P~     |= P0    holds.

	Note that these two properties are just simple iterations of the rules (reg-subst) and (reg-cut).

	これらの2つのプロパティのルール（REG-SUBST）と（REGカット）の単純な繰り返しがあることに注意してください。

	----

	In the rest of this section, we first present a model-theoretic approach to establishing the consistency of a regular constraint relation, and then show some concrete examples of type index languages.

	このセクションの残りの部分では、まず、通常の制約関係の整合性を確立するモデル理論アプローチを提示してから、タイプインデックス言語のいくつかの具体例を示している。

	At this point, an alternative is for the reader to proceed directly to the next section and then return at a later time.

	読者は、次のセクションに直接進むと、後で返すようにするためにこの時点で、代替案がある。

- 3.2 Models for type index languages

	We now present an approach to constructing regular constraint relations for type index languages.

	現在タイプインデックス言語の定期的な制約関係を構築するためのアプローチを提示。

	The approach, due to Henkin (Henkin, 1950), is commonly used in the construction of models for simple type theories.

	ヘン（ヘン、1950）によるアプローチは、一般的に単純型理論のモデルの作成に使用される。

	The presentation of this approach given below is entirely adopted from Chapter 5 (Andrews, 1986).

	下記のこのアプローチのプレゼンテーションでは、完全に、第5章（アンドリュース、1986）から採用されている。

	Also, some details on constructing Henkin models can be found in (Andrews, 1972; Mitchell & Scott, 1989).

	（;ミッチェル＆スコット、1989アンドリュース、1972）。また、ヘンケンモデルを構築する上で、いくつかの詳細が記載されています。

	----

	We use D for domains (sets).

	我々は、ドメイン（セット）のためにDを使用しています。

	Given two domains D1 and D2, we use D1 × D2 for the usual product set {ha1, a2i | a1 ∈ D1 and a2 ∈ D2}, and π1 and π2 for the standard projection functions from D1 × D2 to D1 and D2, respectively.

	それぞれD1およびD2、D1から×D2から標準の投影機能用、およびπ1とπ2|つのドメインD1およびD2を考えると、我々は通常の製品セット{A1∈D1とa2∈D2 HA1、a2i}のためにD1×D2を使用。

	----

	Let sort be the (possibly infinite) set of all sorts in L.

	ソートL.におけるあらゆる種類の（おそらく無限の）集合とする

	A frame is a collection {Ds}s∈sort of nonempty domains Ds, one for each sort s.


	フレームが空でないドメインのDS、各ソートsの1のコレクション{Dsは}s∈sortです。

	We require that Dbool = {tt, ff}, where tt and ff refer to two distinct elements representing truth and falsehood, respectively, and Ds1∗s2 = Ds1 × Ds2 and Ds1→s2 be some collection of functions from Ds1 to Ds2 (but not necessarily all the functions from Ds1 to Ds2).

	我々は、Dbool={TTは、FF}、TTはとFFそれぞれ、真実と虚偽を表す2つの異なる要素を参照してくださいどこにする必要があり、およびDS1* S2 = Ds1を×Ds2におよびDS1→S2（Ds2とのDs1をから機能の一部収集をすることが、 Ds1がからDs2のに必ずしもすべての機能）。

	An interpretation h{Ds}s∈sort, Ii of L consists of a frame {Ds}s∈sort and a function I that maps each constant C of c-sort (s1, . . . , sn) ⇒ b to a function I(C) from Ds1 × . . . × Dsn into Db (or to an element in Db if n = 0), where b stands for a base sort.

	In particular, we require that
	
	- I(true) = tt and I(false) = ff, and
	- I(.=s) be the equality function of the domain Ds for each sort s.
	
	Assume that the arity of a constructor C is n. Then C(I1, . . . , In) .= C(I0 1, . . . , I0 n)　implies that Ii .= I0 i for 1 ≤ i ≤ n. Therefore, for each constructor C, we require that I(C) be an injective (a.k.a. 1-1) function.

	----

	An assignment η is a finite mapping from index variables to D = ∪s∈sortDs, and we use dom(η) for the domain of η. As usual, we use [] for the empty mapping and η[a 7→ a] for the mapping that extends η with one additional link from a to a, where a 6∈ dom(η) is assumed.

	We write η : φ if η(a) ∈ Dφ(a) holds for each a ∈ dom(η) = dom(φ).

	An interpretation M = h{Ds}s∈sort, Ii of S, which is the signature associated with L, is a model for L if there exists a (partial) binary function VM such that for each assignment η satisfying η : φ for some φ and each index term I, VM(η, I) is properly defined such that VM(η, I) ∈ Ds holds whenever φ |- I : s is derivable for some sort s, and the following conditions are also met:

	1. VM(η, a) = η(a) for each a ∈ dom(η), and
	2. VM(η, C(I1, . . . , In)) = I(C)(VM(η, I1), . . . , VM(η, In)), and
	3. VM(η,hI1, I2i) = hVM(η, I1), VM(η, I2)i, and
	4. VM(η, π1(I)) = π1(VM(η, I)) whenever φ ` I : s1 ∗ s2 is derivable for some sorts s1 and s2, and
	5. VM(η, π2(I)) = π2(VM(η, I)), whenever φ ` I : s1 ∗ s2 is derivable for some sorts s1 and s2, and
	6. VM(η, I1(I2)) = VM(η, I1)(VM(η, I2)) whenever φ ` I1(I2) : s is derivable for some sort s, and
	7. VM(η, λa : s1.I) is the function that maps each element a in the domain Ds1 to VM(η[a 7→ a], I) whenever φ ` λa : s1.I : s1 → s2 is derivable for some sort s2.

	Note that not all interpretations are models (Andrews, 1972).

	Given a model M for L, we can define a constraint relation |=M as follows: φ; P~ |=M P0 holds if and only if for each assignment η such that η : φ holds, VM(η, P0) = tt or VM(η, P) = ff for some P ∈ P~ .

	- Proposition 3.2

		The constraint relation |=M is regular.

	- Proof

		It is a simple routine to verify that each of the regularity rules listed in Figure 9 is valid.　□
		
	Therefore, we have shown that for any given type index language L, there always exists a regular constraint relation if a model can be constructed for L.

	Of course, in practice, we need to focus on regular constraint relations that can be decided in an algorithmically effective manner.

- 3.3 Some examples of type index languages

- 3.3.1 A type index language Lalg

	We now describe a type index language Lalg in which only algebraic terms can be formed.

	Suppose that there are some base sorts in Lalg .

	For each base sort b, there exists some constructors of c-sorts (b1, . . . , bn) ⇒ b for constructing terms of the base sort b, and we say that these constructors are associated with the sort b.

	In general, the terms in Lalg can be formed as follows, index terms I ::= a | C(I1, . . . , In) where C is a constructor or an equality constant function .=s for some sort s.

	For instance, we may have a sort Nat and two constructors Z and S of c-sorts () ⇒ Nat and (Nat) ⇒ Nat, respectively, for constructing terms of sort Nat.

	A constraint in Lalg is of the following form:

		a1 : b1, . . . , an : bn; I1 .= I 0 1 , . . . , In .= I 0 n |= I .= I 0

	where each .= is .=s for some sort s.

	A simple rule-based algorithm for solving this kind of constraints can be found in (Xi et al., 2003), where algebraic terms are used to represent types.

	----

	In practice, we can provide a mechanism for adding into Lalg a new base sort b as well as the constructors associated with b.

	As an example, we may use the following concrete syntax:

		datasort stp =
		Bool | Integer | Arrow of (stp, stp) | Pair of (stp, stp)

	to introduce a sort stp and then associate with it some constructors of the following c-sorts:

		Bool : () ⇒ stp
		Integer : () ⇒ stp
		Arrow : (stp, stp) ⇒ stp
		Pair : (stp, stp) ⇒ stp

	We can then use index terms of the sort stp to represent the types in a simply typed λ-calculus where tuples are supported and there are also base types for booleans and integers.

	In Section 7.3, we will present a concrete programming example involving the type index language Lalg .

- 3.3.2 Another type index language Lint

	We now formally describe another type index language Lint in which we can form integer expressions.

	The syntax for Lint is given as follows:
	
		index sorts s ::= bool | int
		index terms I ::= a | C(I1, . . . , In)
	
	There are no tuples and functions (formed through λ-abstraction) in Lint, and the constants C in Lint together with their c-sorts are listed in Figure 10.

	Let Dint be the domain (set) of integers and Mint be h{Dbool , Dint}, Iinti, where Iint maps each constant in Lint to its standard interpretation.

	For instance, I(+) and I(−) are the standard addition and subtraction functions on integers, respectively.

	It can be readily verified that Mint is a model for Lint. Therefore, the constraint relation |=Mint is regular.

		true : () → bool
		false : () → bool
		i : () → int for every integer i
		¬ : (bool) → bool negation
		∧ : (bool, bool) → bool conjunction
		∨ : (bool, bool) → bool disjunction
		+ : (int, int) → int
		− : (int, int) → int
		: (int, int) → int
		/ : (int, int) → int
		max : (int, int) → int
		min : (int, int) → int
		mod : (int, int) → int modulo operation
		≥ : (int, int) → bool
		> : (int, int) → bool
		≤ : (int, int) → bool
		< : (int, int) → bool
		= : (int, int) → bool
		6= : (int, int) → bool
		. . . : . . .

	- Fig. 10. The constants and their c-sorts in Lint

		datasort typ = Arrow of (typ, typ) | All of (typ -> typ)
		datatype EXP (typ) =
		| {a1:typ, a2:typ} EXPlam (Arrow (a1, a2)) of (EXP (a1) -> EXP (a2))
		| {a1:typ, a2:typ} EXPapp (a2) of (EXP (Arrow (a1, a2)), EXP (a1))
		| {f:typ -> typ} EXPalli (All (f)) of ({a:typ} EXP (f a))
		| {f:typ -> typ,a:typ} EXPalle (f a) of (EXP (All f))

	- Fig. 11. An example involving higher-order type index terms

	Given a constraint φ; P~ |=Mint P0, where φ = a1 : int, . . . , an : int, and each P in P~ is a linear inequality on integers, and P0 is also a linear inequality on integers, we can use linear integer programming to solve such a constraint.

	制約φを考える。 P〜|=ミントP0、どこに、φ=のA1：int型、。 。 。 、：int型、およびP〜の各Pは整数に対する線形不等式であり、P0は、我々はそのような制約を解決するために、線形整数計画を使用することができ、また、整数上の線形不等式です。

	We will mention later that we can make use of the type index language Lint in the design of a dependently type functional programming language where type equality between two types can be decided through linear integer programming.

	我々はの設計タイプインデックス言語リントを利用することができ、後に言及します依存して二種類のタイプの平等は線形整数計画を経て決定することができる機能的なプログラミング言語を入力します。

	Though the problem of linear integer programming itself is NP-complete, we have observed that the overwhelming majority of constraints encountered in practice can be solved in a manner that is efficient enough to support realistic programming.

	線形整数計画自体の問題は、NP完全であるが、我々は、実際に遭遇する制約の圧倒的多数は、現実的なプログラミングをサポートするのに十分に効率的な方法で解決することができることを観察した。

- 3.3.3 Higher-order type index terms

	There are no higher-order type indexes, that is, type index terms of function sorts, in either Lalg or Lint.

	高次タイプのインデックスはLalgや糸くずのどちらかの関数の種類、のタイプインデックスの用語は、つまり、全くありません。

	In general, the constraint relation involving higher-order type indexes are often difficult or simply intractable to solve.

	一般に、高次型索引付けに関連する制約関係は、しばしば困難または解決することが簡単に難治性である。

	We now present a type index language Lλ, which extends Lalg with higher-order type indexes as follows:

	我々は現在、次のように高次タイプのインデックスとLalgを拡張タイプインデックス言語Lλを提示：

		index terms I ::= . . . | λa : s.I | I1(I2)

	Like in Lalg , a constraint in Lλ is of the following form:

	Lalgのように、Lλで制約は以下の形式は次のとおりです。

		a1 : b1, . . . , an : bn; I1 .= I 0 1 , . . . , In .= I 0 n |= I .= I 0

	For instance, we may ask whether the following constraint holds:

	たとえば、我々は以下の制約が成立するかどうか尋ねる場合があります:

		a1 : b → b, a2 : b; a1(a1(a2)) .= a1(a2) |= a1(a2) = a2

	If there are two distinct constants C1 and C2 of sort b, then the answer is negative since a counterexample can be constructed by letting a1 and a2 be λa : b.C1 and C2, respectively.

	それぞれ、b.C1及びC2：つの異なる定数C1とソートbのC2がある場合反例をa1とa2をλaとすることがせることによって構築することができるので、答えは否定的である。

	Clearly, the problem of solving constraints in Lλ is undecidable as (a special case of) it can be reduced to the problem of higher-order unification.


	（特別な場合）には高次の統一の問題に還元することができるように明確に、Lλに制約を解決する問題が決定不能である。

	For instance, φ; I1 .= I2 |= false holds if and only if there exists no substitution Θ : φ such that I1[Θ] and I2[Θ] are βη-equivalent.

	例えば、φ。 I1= I2|=全く代替Θが存在しないとする場合にのみ場合はfalseが成り立つ：。そのようなφI1[Θ]とI2[Θ]はβη等価であること。

	----

	In practice, we can decide to only handle constraints of the following simplified form:

	実際には、我々は唯一以下の簡略化した形の制約を処理するために決定することができます。

		φ; a1.= I1, . . . , an.= In |= I.= I0

	where for 1 ≤ i ≤ j ≤ n, there are no free occurrences of aj in Ii.

	1≤のために、私はJの≤nを≤場所、井伊でAJの空き出現はありません。


	Solving such a constraint can essentially be reduced to deciding the βη-equality on two simply typed λ-terms, which is done by comparing whether the two λ-terms have the same long βη-normal form.

	解決そのような制約は、基本的に2つのλ-用語が同じ長いβη-正規形を持っているかどうかを比較することによって行われている2単に入力されたλ-条件でβη-平等を、決定に還元することができる。

	----

	We now present an example that makes use of higher-order type indexes.

	我々は現在、高次タイプのインデックスを利用した例を提示する。

	The constraints on type indexes involved in this example have the above simplified form and thus can be easily solved using βη-normalization.

	この例では、関連するタイプのインデックスに対する制約は、上記の簡略化した形態を有し、したがって、容易にβη正規化を使用して解くことができる。

	The concrete syntax in Figure 11 declares a sort typ and a type constructor EXP that takes an index term I of sort typ to form a type EXP(I).

	図11の具体的な構文は、ソートTYPとタイプEXP（I）を形成するために、一種の標準索引用語Iをとり型コンストラクタのEXPを宣言します。

	The value constructors associated with EXP are assigned the following c-types:

	EXPに関連付けられた値コンストラクタは、次のC-タイプが割り当てられています。

		EXPlam : Πa1 :typ.Πa2 :typ.
			(EXP(a1) → EXP(a2)) ⇒ EXP(Arrow(a1, a2))
		EXPapp : Πa1 :typ.Πa2 :typ.
			(EXP(Arrow(a1, a2)), EXP(a1)) ⇒ EXP(a2)
		EXPalli : Πf :typ → typ.
			(Πa:typ. EXP(f(a))) ⇒ EXP(All(f))
		EXPalle : Πf :typ → typ.Πa:typ.
			(EXP(All(f))) ⇒ EXP(f(a))

	The intent is to use an index term I of sort typ to represent a type in the secondorder polymorphic λ-calculus λ2 (a.k.a. system F), and a value of type EXP(I) to represent a λ-term in λ2 that can be assigned the type represented by I.

	意図ができλ2におけるλ期を表現するためにsecondorder多型λ計算のλ2（別名システムF）を入力し、タイプEXP（I）の値を表すために、一種の標準索引用語Iを使用することですIで表さタイプが割り当て

	For instance, the type ∀α. α → α is represented as All(λa : typ. Arrow(a, a)), and the following term:

	例えば、タイプの∀α。 α→αはすべてのように表される（λaは：。TYP矢印（、a）参照）、および以下の言葉を。

		EXPalli(Π+(EXPalli(Π+(EXPlam(lamx. EXPlam(lamy. EXPapp(y, x)))))))

	----


		types τ ::= . . . | δ(
		~I) | P ⊃ τ | P ∧ τ | Πa:s. τ | Σa:s. τ
		expressions e ::= . . . | ⊃
		+(v) | ⊃
		−(e) | Π
		+(v) | Π
		−(e) |
		∧(e) | let ∧ (x) = e1 in e2 end |
		Σ(e) | let Σ(x) = e1 in e2 end
		values v ::= . . . | ⊃
		+(v) | Π
		+(v) | ∧(v) | Σ(v)

		Fig. 12. The syntax for λ Π,Σ pat

	which can be given the following type:

	これは、次の型を与えることができる：

		EXP(All(λa1 : typ. All(λa2 : typ. Arrow(a1, Arrow(Arrow(a1, a2), a2)))))

	represents the λ-term Λα1.Λα2.λx : α1.λy : α1 → α2.y(x).

	λ長期Λα1.Λα2.λxが表す：α1.λy：α1は→α2.y（X）。

	This is a form of higherorder abstract syntax (h.o.a.s.) representation for λ-terms (Church, 1940; Pfenning & Elliott, 1988; Pfenning, n.d.).

	これはλ-用語（;プフェニング＆エリオット、1988;プフェニング、ND教会、1940）のためのhigherorder抽象構文（のHoA）表現の一形態である。

	As there is some unfamiliar syntax involved in this example, we suggest that the reader revisit it after studying Section 4.

	この例に関わるいくつかのなじみのない構文があるように、我々は読者が第4節を勉強した後にそれを再検討することを示唆している。
