- 5.3 Some explanation on analysis elaboration rules
	
	The rules for analysis elaboration judgments are presented in Figure 23.

	For instance, if e = he1, e2 i and τ = hτ1, τ2i, then the rule (elab-dn-prod) reduces the question whether e can be assigned the type τ to the questions whether ei can be assigned the types τi for i = 1, 2. Most of analysis elaboration rules are straightforward.
	
	In the rule (elab-dn-up), we see that the three forms of judgments (dynamic subtype judgment, synthesis elaboration judgment and analysis elaboration judgment) meet.

	This rule simply means that when analyzing whether an expression e can be given a type τ2, we may first synthesize a type τ1 for e and then show that τ1 is a dynamic subtype of τ2 (by showing that E : τ1 ≤ τ2 is derivable for some evaluation context E).

	In practice, we apply the rule (elab-dn-up) only if all other analysis elaboration rules are inapplicable.

	----

	We now show some actual use of analysis elaboration rules by presenting in Figure 26 a derivation of the following judgment for some E:
	
		∅; ∅ ` E : Nat ∗ Nat ≤ Σa1 :nat.Σa2 :nat. int(a1) ∗ int(a2)

	where Nat = Σa : nat. int(a). In this derivation, we assume the existence of a

		τ0 = int(a1) ∗ int(a2)
		τ1 = Σa2 :nat. int(a1) ∗ int(a2)
		τ2 = Σa1 :nat.Σa2 :nat. int(a1) ∗ int(a2)
		φ1 = ∅, a1 : int
		φ2 = ∅, a1 : int, a2 : int
		P~1 = ∅, a1 ≥ 0
		P~2 = ∅, a1 ≥ 0, a2 ≥ 0
		E0 = Σ(∧(Σ(∧(let hx1, x2i = [] in hx1, x2i end))))
		e1 = E0[hx1, x2i]
		e2 = let Σ(∧(x2)) = x2 in e1 end
		e3 = let Σ(∧(x1)) = x1 in e2 end
		E = let hx1, x2i = [] in e3 end
		D1 :: φ2;P~2; x1 : int(a1), x2 : int(a2) ` x1 ↑ int(a1) ⇒ x1
		(elab-var-up)
		D2 :: φ2;P~2; x1 : int(a1), x2 : int(a2) ` x2 ↑ int(a2) ⇒ x2
		(elab-var-up)
		D1
		φ2; P~2 |= a1
		.
		= a1
		φ2; P~2 ` [] : int(a1) ≤ int(a1)
		D3 :: φ2; P~2; x1 : int(a1), x2 : int(a2) ` x1 ↓ int(a1) ⇒ x1
		(elab-dn-up)
		D2
		φ2; P~2 |= a2
		.= a2
		φ2; P~2 ` [] : int(a2) ≤ int(a2)
		D4 :: φ2; P~2; x1 : int(a1), x2 : int(a2) ` x2 ↓ int(a2) ⇒ x2
		(elab-dn-up)
		D3 D4
		D5 :: φ2; P~2; x1 : int(a1), x2 : int(a2) ` hx1, x2i ↓ τ0 ⇒ hx1, x2i
		(elab-dn-prod)
		D5 D0 :: φ2;P~2 ` E0 : τ0 ≤ τ2
		D6 :: φ2; P~2; x1 : int(a1), x2 : int(a2) ` hx1, x2i ↓ τ2 ⇒ e1
		(elab-dn-up)
		φ1; P~1; x1 : int(a1), x2 : Nat ` hx1, x2i ↓ τ2 ⇒ e2
		(elab-dn-Σ-left)
		∅; ∅; x1 : Nat, x2 : Nat ` hx1, x2i ↓ τ2 ⇒ e3
		(elab-dn-Σ-left)
		D7 :: ∅; ∅ ` E : Nat ∗ Nat ≤ τ2
		(dy-sub-prod)

	- Fig. 26. Another example of elaboration

	derivation D0 :: φ2; P~2 ` E0 : τ0 ≤ τ2 for the following evaluation context E0:

		Σ(∧(Σ(∧(let hx1, x2i = [] in hx1, x2i end))))

	which can be readily constructed.

	----

	As another example, the interested reader can readily derive the following judgment for some E:

		∅; ∅ ` E : Πa:int. int(a) → int(a) ≤ Int → Int

	where Int = Σa : int. int(a).

	Therefore, we can always use a function of the type

		Πa:int. int(a) → int(a) as a function of the type Int → Int.
